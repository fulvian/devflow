# CLAUDE.sessions.md

This file provides collaborative guidance and philosophy when using the Claude Code Sessions system.

## Collaboration Philosophy

**Core Principles**:
- **Investigate patterns** - Look for existing examples, understand established conventions, don't reinvent what already exists
- **Confirm approach** - Explain your reasoning, show what you found in the codebase, get consensus before proceeding  
- **State your case if you disagree** - Present multiple viewpoints when architectural decisions have trade-offs
- When working on highly standardized tasks: Provide SOTA (State of the Art) best practices
- When working on paradigm-breaking approaches: Generate "opinion" through rigorous deductive reasoning from available evidence

## Task Management

### Best Practices
- One task at a time (check .claude/state/current_task.json)
- Update work logs as you progress  
- Mark todos as completed immediately after finishing

### Quick State Checks
```bash
cat .claude/state/current_task.json  # Shows current task
git branch --show-current             # Current branch/task
```

### current_task.json Format

**ALWAYS use this exact format for .claude/state/current_task.json:**
```json
{
  "task": "task-name",        // Just the task name, NO path, NO .md extension
  "branch": "feature/branch", // Git branch (NOT "branch_name")
  "services": ["service1"],   // Array of affected services/modules
  "updated": "2025-08-27"     // Current date in YYYY-MM-DD format
}
```

**Common mistakes to avoid:**
- ❌ Using `"task_file"` instead of `"task"`
- ❌ Using `"branch_name"` instead of `"branch"`  
- ❌ Including path like `"tasks/m-task.md"`
- ❌ Including `.md` file extension

## Using Specialized Agents

You have specialized subagents for heavy lifting. Each operates in its own context window and returns structured results.

### Prompting Agents
Agent descriptions will contain instructions for invocation and prompting. In general, it is safer to issue lightweight prompts. You should only expand/explain in your Task call prompt  insofar as your instructions for the agent are special/requested by the user, divergent from the normal agent use case, or mandated by the agent's description. Otherwise, assume that the agent will have all the context and instruction they need.

Specifically, avoid long prompts when invoking the logging or context-refinement agents. These agents receive the full history of the session and can infer all context from it.

### Available Agents

1. **context-gathering** - Creates comprehensive context manifests for tasks
   - Use when: Creating new task OR task lacks context manifest
   - ALWAYS provide the task file path so the agent can update it directly

2. **code-review** - Reviews code for quality and security
   - Use when: After writing significant code, before commits
   - Provide files and line ranges where code was implemented

3. **context-refinement** - Updates context with discoveries from work session
   - Use when: End of context window (if task continuing)

4. **logging** - Maintains clean chronological logs
   - Use when: End of context window or task completion

5. **service-documentation** - Updates service CLAUDE.md files
   - Use when: After service changes

### Agent Principles
- **Delegate heavy work** - Let agents handle file-heavy operations
- **Be specific** - Give agents clear context and goals
- **One agent, one job** - Don't combine responsibilities

## Code Philosophy

### Locality of Behavior
- Keep related code close together rather than over-abstracting
- Code that relates to a process should be near that process
- Functions that serve as interfaces to data structures should live with those structures

### Solve Today's Problems
- Deal with local problems that exist today
- Avoid excessive abstraction for hypothetical future problems

### Minimal Abstraction
- Prefer simple function calls over complex inheritance hierarchies
- Just calling a function is cleaner than complex inheritance scenarios

### Readability > Cleverness
- Code should be obvious and easy to follow
- Same structure in every file reduces cognitive load

## Protocol Management

### CRITICAL: Protocol Recognition Principle

**When the user mentions protocols:**

1. **EXPLICIT requests → Read protocol first, then execute**
   - Clear commands like "let's compact", "complete the task", "create a new task"
   - Read the relevant protocol file immediately and proceed

2. **VAGUE indications → Confirm first, read only if confirmed**
   - Ambiguous statements like "I think we're done", "context seems full"
   - Ask if they want to run the protocol BEFORE reading the file
   - Only read the protocol file after they confirm

**Never attempt to run protocols from memory. Always read the protocol file before executing.**

### Protocol Files and Recognition

These protocols guide specific workflows:

1. **sessions/protocols/task-creation.md** - Creating new tasks
   - EXPLICIT: "create a new task", "let's make a task for X"
   - VAGUE: "we should track this", "might need a task for that"

2. **sessions/protocols/task-startup.md** - Beginning work on existing tasks  
   - EXPLICIT: "switch to task X", "let's work on task Y"
   - VAGUE: "maybe we should look at the other thing"

3. **sessions/protocols/task-completion.md** - Completing and closing tasks
   - EXPLICIT: "complete the task", "finish this task", "mark it done"
   - VAGUE: "I think we're done", "this might be finished"

4. **sessions/protocols/context-compaction.md** - Managing context window limits
   - EXPLICIT: "let's compact", "run context compaction", "compact and restart"
   - VAGUE: "context is getting full", "we're using a lot of tokens"

### Behavioral Examples

**Explicit → Read and execute:**
- User: "Let's complete this task"
- You: [Read task-completion.md first] → "I'll complete the task now. Running the logging agent..."

**Vague → Confirm before reading:**
- User: "I think we might be done here"
- You: "Would you like me to run the task completion protocol?"
- User: "Yes"
- You: [NOW read task-completion.md] → "I'll complete the task now..."

## Synthetic.new Multi-Agent Integration Protocol

### **Primary AI Coordination System**
DevFlow utilizza Synthetic.new come primary platform con specialization per agent type:
- **Code Agent** (Qwen 2.5 Coder): Implementation, APIs, refactoring, rapid prototyping
- **Reasoning Agent** (DeepSeek V3): Architecture analysis, complex decisions, strategic planning
- **Context Agent** (Qwen 72B): Large codebase analysis, documentation, context understanding
- **Auto Agent**: Intelligent model selection based on task classification

### **MANDATORY Synthetic Delegation Rules**
1. **SEMPRE delegare coding tasks** a Synthetic specialized agents - MAI implementazione diretta
2. **USE MCP TOOLS**: Usare SOLO i tool MCP Synthetic disponibili (NON CCR per delegation)
3. **Task ID Standard**: Format DEVFLOW-[COMPONENT]-[SEQUENCE] (e.g., DEVFLOW-P2-VECTOR-001)
4. **Tool Selection**: synthetic_code | synthetic_reasoning | synthetic_context | synthetic_auto  
5. **Immediate Implementation**: Codice generato da Synthetic → Implementazione automatica nel progetto
6. **Quality Control**: Architect review del codice generato prima dell'integrazione
7. **Memory Persistence**: Aggiornare work logs con risultati e decisioni tecniche

### **MCP SYNTHETIC TOOLS - USAGE PROTOCOL**

#### **Tool 1: synthetic_code** (Qwen3-Coder-480B-A35B-Instruct)
**When**: Implementation, APIs, refactoring, rapid prototyping
**Parameters**:
- task_id: DEVFLOW-[COMPONENT]-[SEQUENCE] 
- objective: Clear description of code to generate
- language: typescript | python | javascript | etc
- requirements: Array of technical requirements
- context: Existing code or additional context

#### **Tool 2: synthetic_reasoning** (DeepSeek-V3)  
**When**: Architecture analysis, complex decisions, strategic planning
**Parameters**:
- task_id: DEVFLOW-[COMPONENT]-[SEQUENCE]
- problem: Problem to analyze or reason about  
- context: Relevant context for reasoning
- approach: analytical | creative | systematic | comparative

#### **Tool 3: synthetic_context** (Qwen2.5-Coder-32B-Instruct)
**When**: Large codebase analysis, documentation, context understanding
**Parameters**: 
- task_id: DEVFLOW-[COMPONENT]-[SEQUENCE]
- content: Content to analyze
- analysis_type: summarize | extract | classify | explain
- focus: Specific aspect to focus on

#### **Tool 4: synthetic_auto** (Intelligent Model Selection)
**When**: Mixed tasks or unclear classification
**Parameters**:
- task_id: DEVFLOW-[COMPONENT]-[SEQUENCE] 
- request: Task description for autonomous execution
- constraints: Array of constraints and requirements
- approval_required: boolean (default true)

### **Agent Selection Guidelines**
- **Code Tasks**: Implementations, functions, APIs, integrations → **Code Agent**
- **Architecture Tasks**: System design, analysis, complex decisions → **Reasoning Agent**  
- **Documentation Tasks**: Large context analysis, documentation → **Context Agent**
- **Mixed Tasks**: Unclear classification → **Auto Agent** (intelligent selection)

### **MCP Codex Integration Protocol**
DevFlow utilizza il server MCP OpenAI Codex per task delegation tramite tools:
- `mcp__openai_codex__codex_completion`: General prompt-based generation
- `mcp__openai_codex__write_code`: Generate code in specific languages  
- `mcp__openai_codex__explain_code`: Provide detailed code explanations
- `mcp__openai_codex__debug_code`: Identify and fix code issues

### **MANDATORY MCP Usage Rules**
1. **SEMPRE usare MCP tools** per task Codex - MAI manual prompting
2. **MCP Server**: http://localhost:8000 con metodi codex_completion, write_code, explain_code, debug_code
3. **Task ID Standard**: Format CODEX-[SPRINT][PHASE] (e.g., CODEX-1A, CODEX-2B, CODEX-4A)
4. **Structured Context**: Fornire sempre context completo via MCP parameters
5. **Validation Required**: Verificare output Codex prima di integration
6. **Memory Persistence**: Salvare risultati in DevFlow memory system
7. **Automatic Synthetic Fallback**: Se MCP Codex non disponibile o raggiunge limiti → Delegazione automatica a Synthetic agent appropriato secondo le regole sopra

### **MCP Task Template**
```typescript
interface CodexMCPTask {
  method: 'write_code' | 'codex_completion' | 'explain_code' | 'debug_code';
  task_id: string; // CODEX-[SPRINT][PHASE]
  context: {
    objective: string;
    technical_requirements: string[];
    implementation_guidelines: string[];
    expected_deliverables: string[];
  };
  code?: string; // Per explain_code e debug_code
  language?: string; // Per write_code
}
```

### **Standard Report Format da MCP Codex**
Dopo ogni task MCP, richiedere report strutturato:
```markdown
# CODEX IMPLEMENTATION REPORT - [TASK ID]

## Summary
- Task: [brief description]  
- Files Created/Modified: [list with brief description]
- Dependencies Added: [list]

## Implementation Details
- Key technical decisions and rationale
- Challenges encountered and solutions
- Performance considerations

## Testing & Validation
- Tests implemented
- Integration points validated
- Error handling coverage

## Next Steps
- Integration requirements per Claude Code
- Follow-up tasks identified
- Optimization opportunities
```


## Enforcement Hook System

To maintain proper role separation and ensure optimal code quality, an enforcement hook system has been implemented that prevents the Architect from using direct coding tools.

### Blocked Direct Coding Tools
- Edit
- MultiEdit
- Write
- NotebookEdit

### Required Delegation Matrix

When implementation or modification tasks are needed, the Architect must delegate to specialized agents:

| Task Type | Assigned Agent | Model |
|-----------|----------------|-------|
| Implementation | @synthetic_code | Qwen3-Coder-480B |
| Architecture Analysis | @synthetic_reasoning | DeepSeek-V3 |
| Large Codebase Analysis | @synthetic_context | Qwen2.5-Coder-32B |
| Intelligent Model Selection | @synthetic_auto | Auto-select |
| Debug/Corrections | @MCP_Gemini_CLI | Gemini |

### Usage Examples

```
@synthetic_code Please implement the authentication module with JWT support

@synthetic_reasoning Analyze the current microservices architecture for scalability concerns

@synthetic_context Find all references to the database connection pool across the codebase

@synthetic_auto Determine the best approach for implementing real-time notifications

@MCP_Gemini_CLI Debug why the test suite is failing with connection timeouts
```

This delegation system ensures that each task is handled by the most appropriate agent with the right expertise and context.

## Debug Router Service

The Debug Router Service provides intelligent error classification and routing to the most appropriate debugging service.

### Configuration

No additional configuration is required. The service automatically integrates with existing Gemini, Claude, and Synthetic Auto services.

### Usage Examples

```typescript
import { DebugRouterService } from './packages/core/src/ml/DebugRouterService';
import { GeminiService } from './packages/core/src/ml/GeminiService';
import { ClaudeService } from './packages/core/src/ml/ClaudeService';
import { SyntheticAutoService } from './packages/core/src/ml/SyntheticAutoService';

// Initialize services
const geminiService = new GeminiService();
const claudeService = new ClaudeService();
const syntheticAutoService = new SyntheticAutoService();

// Create debug router
const debugRouter = new DebugRouterService(
  geminiService,
  claudeService,
  syntheticAutoService
);

// Example 1: Syntax Error
const syntaxErrorContext = {
  error: new Error('Unexpected token'),
  code: 'const x = ;',
  stack: 'SyntaxError: Unexpected token',
  timestamp: Date.now(),
  attempt: 1
};

// This will be routed to Gemini first
const syntaxFix = await debugRouter.routeDebugRequest(syntaxErrorContext);

// Example 2: Type Error
const typeErrorContext = {
  error: new Error('Cannot read property of undefined'),
  code: 'console.log(obj.property.subProperty)',
  stack: 'TypeError: Cannot read property of undefined',
  timestamp: Date.now(),
  attempt: 1
};

// This will be routed to Claude first
const typeFix = await debugRouter.routeDebugRequest(typeErrorContext);

// Example 3: Async Error
const asyncErrorContext = {
  error: new Error('UnhandledPromiseRejection'),
  code: 'Promise.reject("error");',
  stack: 'at async PromiseRejectCallback',
  timestamp: Date.now(),
  attempt: 1
};

// This will be routed to Claude first
const asyncFix = await debugRouter.routeDebugRequest(asyncErrorContext);

// Example 4: Unknown Error
const unknownErrorContext = {
  error: new Error('Custom error'),
  code: 'custom code',
  stack: 'CustomStack',
  timestamp: Date.now(),
  attempt: 1
};

// This will use the fallback chain: Gemini → Claude → Synthetic Auto
const unknownFix = await debugRouter.routeDebugRequest(unknownErrorContext);
```

### Error Classification

The service classifies errors into the following categories:

1. **Syntax Errors** - Routed to Gemini (highest priority)
   - Parse errors
   - Unexpected token errors
   - SyntaxError messages

2. **Type Errors** - Routed to Claude (highest priority)
   - TypeError messages
   - "undefined is not a function" errors
   - "Cannot read property" errors

3. **Reference Errors** - Routed to Gemini (medium priority)
   - ReferenceError messages
   - "is not defined" errors

4. **Async Errors** - Routed to Claude (medium priority)
   - Promise-related errors
   - UnhandledPromiseRejection errors
   - Async stack traces

5. **Fallback** - Routed to Synthetic Auto (lowest priority)
   - All errors that don't match other categories
   - Backup when primary services fail

### Fallback Chain

When an error occurs, the service follows this fallback chain:

1. **Primary Classification**: Route to the most appropriate service based on error type
2. **Service Failure**: If the primary service fails, try the next service in the priority list
3. **Complete Failure**: If all services fail, throw an error with details

This ensures that debugging is always attempted with the best available service while providing robust fallbacks.

## Backup Management

DevFlow now includes a centralized backup system to manage all service backups:

### BackupManagerService

The `BackupManagerService` provides a unified interface for creating, restoring, and managing backups across all services.

#### Key Features

- Centralized backup storage outside the repository
- Automatic cleanup of old backups
- Service-specific backup organization
- Registry-based backup tracking

#### Usage

```typescript
import BackupManagerService from '../ml/BackupManagerService';

// Create a backup
const backupId = await BackupManagerService.createBackup('serviceName', filePath, content);

// Restore a backup
const content = await BackupManagerService.restoreBackup(backupId);

// List backups
const backups = await BackupManagerService.listBackups('serviceName');

// Remove a backup
await BackupManagerService.removeBackup(backupId);
```

#### Configuration

Backups are stored in a dedicated `backups/` directory at the project root. The system maintains a maximum of 10 backups per service.

#### Integration

All services that previously created `.bak` files directly in the repository have been updated to use the BackupManagerService instead. This ensures:

1. No backup files are created within the repository
2. All backups are centrally managed
3. Automatic cleanup prevents disk space issues
4. Consistent backup naming and organization

#### .gitignore Updates

The `.gitignore` file has been updated to exclude all `.bak` files and the `backups/` directory from version control.
