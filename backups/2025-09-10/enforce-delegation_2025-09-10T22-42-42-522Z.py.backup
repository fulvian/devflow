# Zero Touch Architecture - Iron-Clad Four-Level Enforcement System
import re
import time
import hashlib
import logging
from typing import List, Dict, Any, Set, Tuple
from dataclasses import dataclass
from enum import Enum

class ViolationLevel(Enum):
    LEVEL_1_TOOL_WHITELIST = 1
    LEVEL_2_COMMAND_BLOCKING = 2
    LEVEL_3_DELEGATION_ENFORCEMENT = 3
    LEVEL_4_CONTEXT_AWARENESS = 4

@dataclass
class EnforcementResult:
    allowed: bool
    level_violated: ViolationLevel = None
    reason: str = ''
    delegation_required: bool = False
    bypass_attempt_detected: bool = False
    confidence_score: float = 1.0
    mathematical_verification: bool = True

class ZeroTouchEnforcer:
    """Iron-clad orchestrator restrictions with mathematical verification and bypass prevention."""
    
    def __init__(self):
        # LEVEL 1: CRITICAL - NO BYPASSES - Mathematical verification
        self.level_1_whitelist: Set[str] = {
            'Read', 'Glob', 'Grep', 'mcp__', 'Task', 'TodoWrite', 
            'WebFetch', 'WebSearch', 'BashOutput', 'KillBash'
        }
        
        # Mathematical verification: total possible tools vs allowed tools
        self.total_tool_count = 50  # Approximate total Claude Code tools
        self.whitelist_ratio = len(self.level_1_whitelist) / self.total_tool_count
        
        # LEVEL 2: Enhanced command pattern blocking with bypass prevention
        self.level_2_blocked_patterns = [
            # File modification commands
            r'\b(mv|rm|cp|mkdir|touch|echo\s*>|>>|sed|awk|chmod|chown)\b',
            # File creation patterns
            r'\.(js|ts|py|json|md|sql|css|html)$',
            # Subprocess bypass attempts
            r'\b(subprocess|popen|system|exec|eval)\b',
            # Shell escapes
            r'[;&|`$]',
            # Environment manipulation
            r'\b(export|set|unset)\s+\w+',
            # Package managers (potential code installation)
            r'\b(npm|pip|yarn|pnpm)\s+(install|add|update)\b'
        ]
        
        # LEVEL 3: Expanded delegation triggers with intelligence
        self.level_3_delegation_triggers = [
            'implement', 'write', 'modify', 'create', 'update', 'delete',
            'function', 'class', 'method', 'component', 'fix', 'add', 
            'remove', 'change', 'build', 'install', 'deploy', 'setup',
            'configure', 'refactor', 'optimize', 'debug', 'test'
        ]
        
        # LEVEL 4: Enhanced code pattern detection
        self.level_4_code_indicators = [
            r'```[a-z]*\n', r'function\s+\w+\s*\(', r'class\s+\w+',
            r'import\s+\w+', r'export\s+\w+', r'const\s+\w+',
            r'let\s+\w+', r'var\s+\w+', r'def\s+\w+\s*\(',
            r'interface\s+\w+', r'type\s+\w+\s*=', r'module\.exports',
            r'require\s*\(', r'from\s+\w+\s+import', r'#include\s*<',
            r'public\s+class', r'private\s+\w+', r'protected\s+\w+'
        ]
        
        # Enforcement tracking
        self.last_command_time = 0
        self.cooling_period = 5  # seconds
        self.violation_history: List[Tuple[float, ViolationLevel]] = []
        self.bypass_attempts = 0
        
        # Logging setup
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def level_1_check(self, tool_name: str) -> Tuple[bool, float]:
        """CRITICAL: Block all tools except whitelisted read-only tools with mathematical verification."""
        # Extract base tool name (remove mcp__ prefix for verification)
        base_tool = tool_name.replace('mcp__', '').split('__')[0] if 'mcp__' in tool_name else tool_name
        
        # Mathematical verification: exact match required
        is_allowed = tool_name in self.level_1_whitelist or tool_name.startswith('mcp__')
        
        # Calculate confidence score based on whitelist ratio
        confidence = 1.0 if is_allowed else 0.0
        
        # Log bypass attempts
        if not is_allowed:
            self.bypass_attempts += 1
            self.logger.warning(f"LEVEL 1 VIOLATION: Tool '{tool_name}' blocked. Bypass attempt #{self.bypass_attempts}")
        
        return is_allowed, confidence
    
    def level_2_check(self, command: str) -> Tuple[bool, List[str]]:
        """Enhanced command pattern blocking with bypass detection."""
        violations = []
        
        for pattern in self.level_2_blocked_patterns:
            if re.search(pattern, command, re.IGNORECASE):
                violations.append(f"Pattern '{pattern}' matched in command")
        
        # Additional bypass detection
        if self._detect_encoding_bypass(command):
            violations.append("Encoding bypass attempt detected")
        
        if self._detect_obfuscation(command):
            violations.append("Command obfuscation detected")
        
        is_allowed = len(violations) == 0
        
        if not is_allowed:
            self.logger.warning(f"LEVEL 2 VIOLATION: Command blocked - {violations}")
        
        return is_allowed, violations
    
    def level_3_check(self, task_description: str) -> Tuple[bool, List[str], bool]:
        """Enhanced delegation enforcement with intelligent context analysis."""
        task_lower = task_description.lower()
        triggered_words = []
        delegation_required = False
        
        # Check for explicit delegation triggers
        for trigger in self.level_3_delegation_triggers:
            if trigger in task_lower:
                triggered_words.append(trigger)
                delegation_required = True
        
        # Intelligent context analysis
        if self._analyze_implementation_intent(task_description):
            triggered_words.append("implementation_intent_detected")
            delegation_required = True
        
        # Check for file manipulation intent
        if self._detect_file_manipulation_intent(task_description):
            triggered_words.append("file_manipulation_intent")
            delegation_required = True
        
        if delegation_required:
            self.logger.info(f"LEVEL 3 DELEGATION REQUIRED: Triggers - {triggered_words}")
        
        return not delegation_required, triggered_words, delegation_required
    
    def level_4_check(self, context: str) -> Tuple[bool, List[str], float]:
        """Enhanced context awareness with intelligent code pattern detection."""
        detected_patterns = []
        code_density = 0.0
        
        # Detect code patterns
        for indicator in self.level_4_code_indicators:
            matches = re.findall(indicator, context, re.IGNORECASE)
            if matches:
                detected_patterns.append(f"Pattern '{indicator}' found {len(matches)} times")
                code_density += len(matches)
        
        # Calculate code density ratio
        total_words = len(context.split())
        if total_words > 0:
            code_density = code_density / total_words
        
        # Advanced pattern detection
        if self._detect_code_blocks(context):
            detected_patterns.append("Code blocks detected")
            code_density += 0.3
        
        if self._detect_api_calls(context):
            detected_patterns.append("API/function calls detected")
            code_density += 0.2
        
        # Threshold for code intent detection
        code_intent_detected = code_density > 0.1 or len(detected_patterns) > 2
        
        if code_intent_detected:
            self.logger.info(f"LEVEL 4 CODE INTENT DETECTED: Patterns - {detected_patterns}, Density: {code_density:.3f}")
        
        return not code_intent_detected, detected_patterns, code_density
    
    def cooling_off_check(self) -> Tuple[bool, float]:
        """Enhanced cooling off period with adaptive timing."""
        current_time = time.time()
        time_since_last = current_time - self.last_command_time
        
        # Adaptive cooling period based on violation history
        adaptive_period = self.cooling_period
        if self.bypass_attempts > 3:
            adaptive_period *= 2  # Double cooling period after multiple bypass attempts
        
        if time_since_last < adaptive_period:
            remaining_time = adaptive_period - time_since_last
            self.logger.info(f"COOLING PERIOD: {remaining_time:.1f}s remaining")
            return False, remaining_time
        
        self.last_command_time = current_time
        return True, 0.0
    
    def enforce(self, tool_name: str, command: str, task_description: str, context: str) -> EnforcementResult:
        """Iron-clad enforcement method with mathematical verification and comprehensive logging."""
        
        # Initialize result
        result = EnforcementResult(allowed=True)
        
        # Generate enforcement hash for verification
        enforcement_hash = self._generate_enforcement_hash(tool_name, command, task_description, context)
        self.logger.info(f"ENFORCEMENT SESSION: {enforcement_hash[:8]}")
        
        try:
            # LEVEL 1: CRITICAL - Tool whitelist with mathematical verification
            level_1_allowed, confidence = self.level_1_check(tool_name)
            if not level_1_allowed:
                result.allowed = False
                result.level_violated = ViolationLevel.LEVEL_1_TOOL_WHITELIST
                result.reason = f'CRITICAL: Tool {tool_name} not in whitelist (confidence: {confidence:.3f})'
                result.bypass_attempt_detected = True
                result.confidence_score = confidence
                result.mathematical_verification = self._verify_whitelist_integrity()
                self._log_violation(result)
                return result
            
            # LEVEL 2: Enhanced command pattern blocking
            level_2_allowed, violations = self.level_2_check(command)
            if not level_2_allowed:
                result.allowed = False
                result.level_violated = ViolationLevel.LEVEL_2_COMMAND_BLOCKING
                result.reason = f'Command pattern violations: {"; ".join(violations)}'
                result.bypass_attempt_detected = len(violations) > 1
                self._log_violation(result)
                return result
            
            # LEVEL 3: Enhanced delegation enforcement
            level_3_allowed, triggers, delegation_required = self.level_3_check(task_description)
            if not level_3_allowed:
                result.allowed = False
                result.level_violated = ViolationLevel.LEVEL_3_DELEGATION_ENFORCEMENT
                result.reason = f'Delegation required - triggers: {"; ".join(triggers)}'
                result.delegation_required = delegation_required
                self._log_violation(result)
                return result
            
            # LEVEL 4: Enhanced context awareness
            level_4_allowed, patterns, code_density = self.level_4_check(context)
            if not level_4_allowed:
                result.allowed = False
                result.level_violated = ViolationLevel.LEVEL_4_CONTEXT_AWARENESS
                result.reason = f'Code intent detected - patterns: {"; ".join(patterns[:3])}, density: {code_density:.3f}'
                result.delegation_required = True
                result.confidence_score = code_density
                self._log_violation(result)
                return result
            
            # Enhanced cooling off period
            cooling_allowed, remaining_time = self.cooling_off_check()
            if not cooling_allowed:
                result.allowed = False
                result.level_violated = ViolationLevel.LEVEL_4_CONTEXT_AWARENESS
                result.reason = f'Cooling period active: {remaining_time:.1f}s remaining'
                return result
            
            # All checks passed
            self.logger.info(f"ENFORCEMENT PASSED: {enforcement_hash[:8]} - All levels cleared")
            return result
            
        except Exception as e:
            # Fail-safe: block everything on error
            self.logger.error(f"ENFORCEMENT ERROR: {e} - Defaulting to BLOCK")
            result.allowed = False
            result.level_violated = ViolationLevel.LEVEL_1_TOOL_WHITELIST
            result.reason = f'Enforcement system error: {str(e)}'
            result.mathematical_verification = False
            return result

    # Helper methods for enhanced detection
    
    def _detect_encoding_bypass(self, command: str) -> bool:
        """Detect attempts to bypass command filtering through encoding."""
        # Check for base64, hex, or other encoding patterns
        encoding_patterns = [
            r'base64|b64encode|b64decode',
            r'\\x[0-9a-fA-F]{2}',  # Hex encoding
            r'%[0-9a-fA-F]{2}',     # URL encoding
            r'\\u[0-9a-fA-F]{4}'   # Unicode encoding
        ]
        return any(re.search(pattern, command, re.IGNORECASE) for pattern in encoding_patterns)
    
    def _detect_obfuscation(self, command: str) -> bool:
        """Detect command obfuscation attempts."""
        # Check for suspicious patterns
        obfuscation_indicators = [
            len(re.findall(r'[\\$`]', command)) > 3,  # Too many escape chars
            len(command) > 200 and command.count(' ') < 10,  # Long command with few spaces
            re.search(r'\$\{[^}]{20,}\}', command),  # Complex variable substitution
        ]
        return any(obfuscation_indicators)
    
    def _analyze_implementation_intent(self, description: str) -> bool:
        """Analyze text for implementation intent using NLP-like patterns."""
        implementation_phrases = [
            r'build\s+a\s+\w+', r'make\s+a\s+\w+', r'develop\s+\w+',
            r'code\s+\w+', r'program\s+\w+', r'script\s+\w+',
            r'algorithm\s+for', r'logic\s+for', r'solution\s+for'
        ]
        return any(re.search(phrase, description, re.IGNORECASE) for phrase in implementation_phrases)
    
    def _detect_file_manipulation_intent(self, description: str) -> bool:
        """Detect intent to manipulate files."""
        file_manipulation_phrases = [
            r'save\s+to\s+file', r'write\s+to\s+\w+\.\w+', r'output\s+to\s+\w+',
            r'store\s+in\s+\w+', r'persist\s+\w+', r'backup\s+\w+'
        ]
        return any(re.search(phrase, description, re.IGNORECASE) for phrase in file_manipulation_phrases)
    
    def _detect_code_blocks(self, context: str) -> bool:
        """Enhanced code block detection."""
        code_block_patterns = [
            r'```[a-z]*\n[\s\S]*?```',  # Markdown code blocks
            r'(?m)^    \w+.*$',          # Indented code lines
            r'\n\s*[{};]\s*\n',         # Code structure indicators
        ]
        return any(re.search(pattern, context) for pattern in code_block_patterns)
    
    def _detect_api_calls(self, context: str) -> bool:
        """Detect API or function call patterns."""
        api_patterns = [
            r'\w+\.\w+\s*\(',          # Method calls
            r'\w+\s*\([^)]*\)\s*[{;]', # Function definitions
            r'await\s+\w+',            # Async calls
            r'fetch\s*\(',              # HTTP requests
        ]
        return any(re.search(pattern, context) for pattern in api_patterns)
    
    def _generate_enforcement_hash(self, tool_name: str, command: str, task: str, context: str) -> str:
        """Generate hash for enforcement session tracking."""
        combined = f"{tool_name}:{command}:{task}:{context}:{time.time()}"
        return hashlib.sha256(combined.encode()).hexdigest()
    
    def _verify_whitelist_integrity(self) -> bool:
        """Mathematical verification of whitelist integrity."""
        # Verify no implementation tools are in whitelist
        implementation_tools = {'Edit', 'Write', 'MultiEdit', 'NotebookEdit', 'Bash'}
        intersection = implementation_tools.intersection(self.level_1_whitelist)
        return len(intersection) == 0
    
    def _log_violation(self, result: EnforcementResult) -> None:
        """Log violation for analysis and monitoring."""
        timestamp = time.time()
        self.violation_history.append((timestamp, result.level_violated))
        
        # Keep only recent violations (last 24 hours)
        cutoff = timestamp - 86400
        self.violation_history = [(t, l) for t, l in self.violation_history if t > cutoff]
        
        self.logger.warning(f"VIOLATION LOGGED: Level {result.level_violated.value} - {result.reason}")
    
    def get_enforcement_stats(self) -> Dict[str, Any]:
        """Get comprehensive enforcement statistics."""
        return {
            'total_violations': len(self.violation_history),
            'bypass_attempts': self.bypass_attempts,
            'whitelist_ratio': self.whitelist_ratio,
            'mathematical_verification': self._verify_whitelist_integrity(),
            'recent_violations_by_level': {
                level.value: sum(1 for _, l in self.violation_history if l == level)
                for level in ViolationLevel
            }
        }

# Example usage and comprehensive testing
def main():
    enforcer = ZeroTouchEnforcer()
    
    print("=== Iron-Clad Orchestrator Enforcement System Tests ===")
    
    # Test case 1: Allowed read operation
    result = enforcer.enforce('Read', 'cat file.txt', 'Read configuration', 'Show config')
    print(f'Test 1 (Read): {result.allowed} - {result.reason}')
    
    # Test case 2: Blocked write operation
    result = enforcer.enforce('Write', 'echo data > file.txt', 'Write data', 'Save config')
    print(f'Test 2 (Write): {result.allowed} - {result.reason}')
    
    # Test case 3: Code implementation request
    result = enforcer.enforce('Task', '', 'Implement new feature', '```javascript\nfunction test() {}\n```')
    print(f'Test 3 (Code): {result.allowed} - {result.reason}')
    
    # Test case 4: Bypass attempt detection
    result = enforcer.enforce('Edit', 'base64 encoded command', 'modify files', 'hidden code')
    print(f'Test 4 (Bypass): {result.allowed} - {result.reason}')
    
    # Test case 5: MCP tool (should be allowed)
    result = enforcer.enforce('mcp__synthetic__auto_file', '', 'use synthetic agent', 'delegate task')
    print(f'Test 5 (MCP): {result.allowed} - {result.reason}')
    
    # Show enforcement statistics
    stats = enforcer.get_enforcement_stats()
    print(f"\n=== Enforcement Statistics ===")
    for key, value in stats.items():
        print(f"{key}: {value}")

if __name__ == '__main__':
    main()
