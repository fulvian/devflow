# Proposta di Implementazione per l'Hook Stop/SubagentStop\n\n## 1. Obiettivo\nImplementare una funzione intelligente di salvataggio automatico nell'hook Stop/SubagentStop di Claude Code per preservare il contesto e le attività svolte, sfruttando le capacità esistenti di DevFlow.\n\n## 2. Componenti Principali dell'Implementazione\n\n### 2.1. IntelligentSaveHook\nComponente principale che gestisce il salvataggio intelligente quando l'hook viene attivato.\n\n```javascript\n// .claude/hooks/intelligent-save-hook.js\nconst fs = require('fs');\nconst path = require('path');\n\nclass IntelligentSaveHook {\n  constructor() {\n    this.memoryManager = null; // Riferimento al sistema di memoria di DevFlow\n    this.knowledgeExtractor = null; // Riferimento al Knowledge Extraction Framework\n    this.logger = null; // Sistema di logging\n  }\n\n  async onHookTrigger(hookData) {\n    try {\n      // 1. Inizializzazione\n      await this.initialize();\n      \n      // 2. Analisi del contesto\n      const contextAnalysis = await this.analyzeContext(hookData);\n      \n      // 3. Estrazione della conoscenza\n      const knowledge = await this.extractKnowledge(contextAnalysis);\n      \n      // 4. Salvataggio intelligente\n      await this.intelligentSave(hookData, contextAnalysis, knowledge);\n      \n      // 5. Logging e monitoraggio\n      await this.logSaveOperation(hookData, contextAnalysis);\n      \n      return {\n        continue: true,\n        suppressOutput: false\n      };\n    } catch (error) {\n      await this.handleError(error, hookData);\n      return {\n        continue: true,\n        suppressOutput: false\n      };\n    }\n  }\n\n  async initialize() {\n    // Inizializzazione dei componenti necessari\n    // Questo potrebbe richiedere l'integrazione con il core di DevFlow\n    this.logger = console; // Placeholder per il sistema di logging di DevFlow\n  }\n\n  async analyzeContext(hookData) {\n    // Analisi del contesto basata sui dati dell'hook\n    const transcriptPath = hookData.transcript_path;\n    const sessionId = hookData.session_id;\n    const eventType = hookData.hook_event_name;\n    \n    // Lettura del transcript\n    let transcript = null;\n    if (fs.existsSync(transcriptPath)) {\n      transcript = fs.readFileSync(transcriptPath, 'utf8');\n    }\n    \n    return {\n      transcript,\n      sessionId,\n      eventType,\n      timestamp: new Date().toISOString(),\n      // Altri metadati rilevanti\n    };\n  }\n\n  async extractKnowledge(contextAnalysis) {\n    // Utilizzo del Knowledge Extraction Framework di DevFlow\n    // Questo è un placeholder - l'implementazione reale dipenderebbe\n    // dall'integrazione diretta con il framework\n    return {\n      reasoningChain: [],\n      decisionTrail: [],\n      newPatterns: [],\n      cognitiveUpdates: [],\n      confidence: 0.8\n    };\n  }\n\n  async intelligentSave(hookData, contextAnalysis, knowledge) {\n    // Implementazione del salvataggio intelligente\n    // Questo potrebbe includere:\n    // 1. Selezione dei contenuti più importanti\n    // 2. Classificazione delle informazioni\n    // 3. Persistenza attraverso il sistema di memoria di DevFlow\n    // 4. Creazione di snapshot del contesto\n    // 5. Estrazione di decisioni architetturali\n    \n    this.logger.log(`[IntelligentSave] Salvataggio contesto per ${hookData.hook_event_name}`);\n    \n    // Esempio di salvataggio di un contesto importante\n    if (contextAnalysis.transcript) {\n      // Qui andrebbe l'integrazione con il sistema di memoria di DevFlow\n      // per salvare il contesto in modo strutturato\n      await this.saveContextSnapshot(contextAnalysis);\n    }\n    \n    // Salvataggio della conoscenza estratta\n    if (knowledge && knowledge.decisionTrail.length > 0) {\n      await this.saveKnowledge(knowledge);\n    }\n  }\n\n  async saveContextSnapshot(contextAnalysis) {\n    // Implementazione del salvataggio dello snapshot del contesto\n    // Questo dovrebbe integrarsi con il sistema di memoria di DevFlow\n    this.logger.log(`[IntelligentSave] Snapshot del contesto salvato per sessione ${contextAnalysis.sessionId}`);\n  }\n\n  async saveKnowledge(knowledge) {\n    // Implementazione del salvataggio della conoscenza estratta\n    this.logger.log(`[IntelligentSave] Conoscenza estratta salvata (${knowledge.decisionTrail.length} decisioni)`);\n  }\n\n  async logSaveOperation(hookData, contextAnalysis) {\n    // Logging dell'operazione di salvataggio\n    this.logger.log(`[IntelligentSave] Operazione completata per ${hookData.hook_event_name} - Sessione: ${hookData.session_id}`);\n  }\n\n  async handleError(error, hookData) {\n    // Gestione degli errori con resilienza\n    this.logger.error(`[IntelligentSave] Errore durante il salvataggio: ${error.message}`);\n    \n    // Tentativo di salvataggio minimale\n    try {\n      await this.saveMinimalContext(hookData);\n    } catch (fallbackError) {\n      this.logger.error(`[IntelligentSave] Errore nel salvataggio minimale: ${fallbackError.message}`);\n    }\n  }\n\n  async saveMinimalContext(hookData) {\n    // Salvataggio minimale del contesto in caso di errore\n    this.logger.log(`[IntelligentSave] Salvataggio minimale eseguito per sessione ${hookData.session_id}`);\n  }\n}\n\n// Esportazione per l'utilizzo nell'hook\nmodule.exports = { IntelligentSaveHook };\n```\n\n### 2.2. Hook Stop\nImplementazione specifica per l'hook Stop.\n\n```javascript\n// .claude/hooks/stop-hook.js\nconst { IntelligentSaveHook } = require('./intelligent-save-hook');\n\nasync function main() {\n  let inputData = '';\n  \n  process.stdin.setEncoding('utf8');\n  \n  process.stdin.on('readable', () => {\n    let chunk;\n    while ((chunk = process.stdin.read()) !== null) {\n      inputData += chunk;\n    }\n  });\n  \n  process.stdin.on('end', async () => {\n    try {\n      const hookData = JSON.parse(inputData);\n      \n      // Verifica che sia un evento Stop\n      if (hookData.hook_event_name !== 'Stop') {\n        process.exit(0);\n      }\n      \n      const intelligentSave = new IntelligentSaveHook();\n      const result = await intelligentSave.onHookTrigger(hookData);\n      \n      // Output del risultato\n      console.log(JSON.stringify(result));\n      process.exit(0);\n    } catch (error) {\n      console.error('Errore nell\\'hook Stop:', error.message);\n      process.exit(1);\n    }\n  });\n}\n\nif (require.main === module) {\n  main();\n}\n```\n\n### 2.3. Hook SubagentStop\nImplementazione specifica per l'hook SubagentStop.\n\n```javascript\n// .claude/hooks/subagent-stop-hook.js\nconst { IntelligentSaveHook } = require('./intelligent-save-hook');\n\nasync function main() {\n  let inputData = '';\n  \n  process.stdin.setEncoding('utf8');\n  \n  process.stdin.on('readable', () => {\n    let chunk;\n    while ((chunk = process.stdin.read()) !== null) {\n      inputData += chunk;\n    }\n  });\n  \n  process.stdin.on('end', async () => {\n    try {\n      const hookData = JSON.parse(inputData);\n      \n      // Verifica che sia un evento SubagentStop\n      if (hookData.hook_event_name !== 'SubagentStop') {\n        process.exit(0);\n      }\n      \n      const intelligentSave = new IntelligentSaveHook();\n      const result = await intelligentSave.onHookTrigger(hookData);\n      \n      // Output del risultato\n      console.log(JSON.stringify(result));\n      process.exit(0);\n    } catch (error) {\n      console.error('Errore nell\\'hook SubagentStop:', error.message);\n      process.exit(1);\n    }\n  });\n}\n\nif (require.main === module) {\n  main();\n}\n```\n\n## 3. Integrazione con i Sistemi di DevFlow\n\n### 3.1. Integrazione con il Sistema di Memoria\nL'hook deve integrarsi con il sistema di memoria di DevFlow per salvare i dati in modo strutturato.\n\n```javascript\n// Esempio di integrazione con il sistema di memoria di DevFlow\nclass DevFlowMemoryIntegration {\n  constructor() {\n    // Qui andrebbe l'inizializzazione del sistema di memoria di DevFlow\n    // Potrebbe richiedere l'accesso ai moduli interni di DevFlow\n  }\n  \n  async saveContextSnapshot(snapshotData) {\n    // Utilizzo del sistema di memoria di DevFlow per salvare lo snapshot\n    // Questo potrebbe coinvolgere:\n    // - Creazione di memory blocks\n    // - Generazione di embeddings semantici\n    // - Applicazione di importance scoring\n    // - Persistenza nel database SQLite\n    \n    console.log('[DevFlowMemory] Salvataggio snapshot del contesto');\n  }\n  \n  async saveKnowledge(knowledgeData) {\n    // Salvataggio della conoscenza estratta nel sistema di memoria\n    console.log('[DevFlowMemory] Salvataggio conoscenza estratta');\n  }\n}\n```\n\n### 3.2. Integrazione con il Knowledge Extraction Framework\nL'hook deve utilizzare il Knowledge Extraction Framework di DevFlow per estrarre informazioni importanti.\n\n```javascript\n// Esempio di integrazione con il Knowledge Extraction Framework\nclass KnowledgeExtractionIntegration {\n  constructor() {\n    // Inizializzazione del framework\n  }\n  \n  async extractFromTranscript(transcript) {\n    // Utilizzo del framework per estrarre conoscenza dal transcript\n    // Questo potrebbe includere:\n    // - Estrazione della reasoning chain\n    // - Identificazione delle decision trails\n    // - Riconoscimento di pattern nuovi\n    // - Estrazione di cognitive updates\n    \n    return {\n      reasoningChain: [],\n      decisionTrail: [],\n      newPatterns: [],\n      cognitiveUpdates: []\n    };\n  }\n}\n```\n\n## 4. Funzionalità Inteligenti di Salvataggio\n\n### 4.1. Selezione Intelligente dei Contenuti\nL'hook deve essere in grado di selezionare solo i contenuti più importanti per il salvataggio.\n\n```javascript\nclass IntelligentContentSelector {\n  constructor() {\n    // Inizializzazione dei criteri di selezione\n  }\n  \n  selectImportantContent(contextAnalysis, knowledge) {\n    // Implementazione di algoritmi per la selezione intelligente:\n    // - Importance scoring basato su DevFlow\n    // - Classificazione dei contenuti (decisioni, pattern, ecc.)\n    // - Filtraggio basato su rilevanza e importanza\n    // - Compattazione del contesto\n    \n    return {\n      importantDecisions: [],\n      keyPatterns: [],\n      criticalContext: [],\n      metadata: {}\n    };\n  }\n}\n```\n\n### 4.2. Classificazione delle Informazioni\nLe informazioni devono essere classificate in base al loro tipo e importanza.\n\n```javascript\nclass InformationClassifier {\n  classify(content) {\n    // Classificazione delle informazioni in base al tipo:\n    // - Decisioni architetturali\n    // - Pattern di implementazione\n    // - Informazioni di contesto\n    // - Conoscenza estratta\n    \n    return {\n      type: 'decision', // o 'pattern', 'context', 'knowledge'\n      importance: 0.9, // Score di importanza\n      tags: ['architecture', 'design'], // Tags per organizzazione\n      relationships: [] // Relazioni con altri contenuti\n    };\n  }\n}\n```\n\n## 5. Gestione degli Errori e Resilienza\n\n### 5.1. Strategie di Fallback\nImplementazione di strategie di fallback per garantire il salvataggio anche in caso di errore.\n\n```javascript\nclass FallbackStrategies {\n  async saveWithFallback(data) {\n    const strategies = [\n      this.saveToDevFlowMemory,\n      this.saveToFileSystem,\n      this.saveToRemoteStorage\n    ];\n    \n    for (const strategy of strategies) {\n      try {\n        await strategy(data);\n        return true;\n      } catch (error) {\n        console.warn(`Strategia di salvataggio fallita: ${error.message}`);\n      }\n    }\n    \n    // Se tutte le strategie falliscono\n    throw new Error('Tutte le strategie di salvataggio sono fallite');\n  }\n  \n  async saveToDevFlowMemory(data) {\n    // Salvataggio nel sistema di memoria principale\n  }\n  \n  async saveToFileSystem(data) {\n    // Salvataggio in file system locale\n  }\n  \n  async saveToRemoteStorage(data) {\n    // Salvataggio in storage remoto\n  }\n}\n```\n\n### 5.2. Pulizia delle Risorse\nGarantire una corretta pulizia delle risorse al termine dell'operazione.\n\n```javascript\nclass ResourceCleanup {\n  async cleanup() {\n    // Pulizia delle risorse:\n    // - Chiusura di connessioni database\n    // - Rilascio di file handles\n    // - Cancellazione di dati temporanei\n    // - Reset di stati interni\n    \n    console.log('[ResourceCleanup] Pulizia risorse completata');\n  }\n}\n```\n\n## 6. Monitoraggio e Logging\n\n### 6.1. Sistema di Logging\nImplementazione di un sistema di logging dettagliato per monitorare le operazioni.\n\n```javascript\nclass IntelligentSaveLogger {\n  logOperation(operation, details) {\n    // Logging strutturato delle operazioni\n    console.log(`[IntelligentSave] ${operation}:`, details);\n  }\n  \n  logError(error, context) {\n    // Logging degli errori con contesto\n    console.error(`[IntelligentSave] Errore: ${error.message}`, context);\n  }\n  \n  logPerformance(metric, value) {\n    // Logging delle metriche di performance\n    console.log(`[IntelligentSave] Performance - ${metric}: ${value}`);\n  }\n}\n```\n\n### 6.2. Monitoraggio delle Metriche\nMonitoraggio delle metriche per ottimizzare le performance.\n\n```javascript\nclass PerformanceMonitor {\n  constructor() {\n    this.metrics = {\n      saveDuration: [],\n      contentSize: [],\n      extractionTime: [],\n      successRate: 0\n    };\n  }\n  \n  recordMetric(metric, value) {\n    if (this.metrics[metric]) {\n      this.metrics[metric].push(value);\n    }\n  }\n  \n  getAverage(metric) {\n    const values = this.metrics[metric];\n    if (values.length === 0) return 0;\n    return values.reduce((a, b) => a + b, 0) / values.length;\n  }\n}\n```\n\n## 7. Configurazione dell'Hook\n\n### 7.1. File di Configurazione\nConfigurazione dell'hook attraverso il file `.claude/settings.json`.\n\n```json\n{\n  \"hooks\": {\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"$CLAUDE_PROJECT_DIR/.claude/hooks/stop-hook.js\"\n          }\n        ]\n      }\n    ],\n    \"SubagentStop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"$CLAUDE_PROJECT_DIR/.claude/hooks/subagent-stop-hook.js\"\n          }\n        ]\n      }\n    ]\n  },\n  \"intelligentSave\": {\n    \"enabled\": true,\n    \"importanceThreshold\": 0.7,\n    \"maxContentSize\": 100000,\n    \"saveDecisions\": true,\n    \"savePatterns\": true,\n    \"saveContext\": true,\n    \"fallbackStrategies\": [\"memory\", \"filesystem\", \"remote\"]\n  }\n}\n```\n\n## 8. Benefici dell'Implementazione\n\n### 8.1. Persistenza Automatica del Contesto\n- Salvataggio automatico del contesto al termine delle sessioni\n- Riduzione del rischio di perdita di informazioni importanti\n- Continuità nel lavoro tra diverse sessioni\n\n### 8.2. Estrazione Intelligente della Conoscenza\n- Identificazione automatica di decisioni architetturali\n- Riconoscimento di pattern utili per futuri progetti\n- Costruzione graduale di una knowledge base\n\n### 8.3. Resilienza e Affidabilità\n- Gestione robusta degli errori con strategie di fallback\n- Logging dettagliato per monitoraggio e debug\n- Pulizia automatica delle risorse\n\n### 8.4. Integrazione con DevFlow\n- Sfruttamento delle capacità esistenti di DevFlow\n- Coerenza con l'architettura e i pattern del sistema\n- Estensibilità per future funzionalità\n\nQuesta implementazione fornirebbe un sistema intelligente di salvataggio automatico che si integra perfettamente con l'ecosistema DevFlow, sfruttando le sue capacità esistenti di gestione della memoria, estrazione della conoscenza e resilienza agli errori.