{
  "modifications": [
    {
      "file": "prova/codex_test/tests/controllers/authController.test.js",
      "operation": "create",
      "content": "const request = require('supertest');\nconst express = require('express');\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\nconst User = require('../../models/User');\nconst RefreshToken = require('../../models/RefreshToken');\nconst authController = require('../../controllers/authController');\n\njest.mock('bcrypt');\njest.mock('jsonwebtoken');\njest.mock('../../models/User');\njest.mock('../../models/RefreshToken');\n\nconst app = express();\napp.use(express.json());\napp.post('/login', authController.login);\napp.post('/register', authController.register);\napp.post('/logout', authController.logout);\napp.post('/refresh', authController.refreshToken);\n\ndescribe('Auth Controller', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('POST /login', () => {\n    it('should login user successfully', async () => {\n      const user = {\n        _id: '123',\n        email: 'test@example.com',\n        password: 'hashedPassword',\n        role: 'user'\n      };\n      \n      User.findOne.mockResolvedValue(user);\n      bcrypt.compare.mockResolvedValue(true);\n      jwt.sign.mockReturnValue('accessToken');\n      RefreshToken.create.mockResolvedValue({ token: 'refreshToken' });\n\n      const response = await request(app)\n        .post('/login')\n        .send({ email: 'test@example.com', password: 'password' });\n\n      expect(response.status).toBe(200);\n      expect(response.body).toHaveProperty('accessToken');\n      expect(response.body).toHaveProperty('refreshToken');\n    });\n\n    it('should return 401 for invalid credentials', async () => {\n      User.findOne.mockResolvedValue(null);\n\n      const response = await request(app)\n        .post('/login')\n        .send({ email: 'test@example.com', password: 'wrong' });\n\n      expect(response.status).toBe(401);\n    });\n\n    it('should return 401 for wrong password', async () => {\n      const user = { email: 'test@example.com', password: 'hashedPassword' };\n      User.findOne.mockResolvedValue(user);\n      bcrypt.compare.mockResolvedValue(false);\n\n      const response = await request(app)\n        .post('/login')\n        .send({ email: 'test@example.com', password: 'wrong' });\n\n      expect(response.status).toBe(401);\n    });\n\n    it('should return 400 for missing fields', async () => {\n      const response = await request(app)\n        .post('/login')\n        .send({ email: 'test@example.com' });\n\n      expect(response.status).toBe(400);\n    });\n  });\n\n  describe('POST /register', () => {\n    it('should register user successfully', async () => {\n      User.findOne.mockResolvedValue(null);\n      bcrypt.hash.mockResolvedValue('hashedPassword');\n      User.create.mockResolvedValue({\n        _id: '123',\n        email: 'test@example.com',\n        role: 'user'\n      });\n\n      const response = await request(app)\n        .post('/register')\n        .send({\n          email: 'test@example.com',\n          password: 'password123',\n          name: 'Test User'\n        });\n\n      expect(response.status).toBe(201);\n      expect(response.body).toHaveProperty('message');\n    });\n\n    it('should return 400 for existing user', async () => {\n      User.findOne.mockResolvedValue({ email: 'test@example.com' });\n\n      const response = await request(app)\n        .post('/register')\n        .send({\n          email: 'test@example.com',\n          password: 'password123',\n          name: 'Test User'\n        });\n\n      expect(response.status).toBe(400);\n    });\n\n    it('should return 400 for invalid email', async () => {\n      const response = await request(app)\n        .post('/register')\n        .send({\n          email: 'invalid-email',\n          password: 'password123',\n          name: 'Test User'\n        });\n\n      expect(response.status).toBe(400);\n    });\n  });\n\n  describe('POST /logout', () => {\n    it('should logout user successfully', async () => {\n      RefreshToken.deleteOne.mockResolvedValue({ deletedCount: 1 });\n\n      const response = await request(app)\n        .post('/logout')\n        .send({ refreshToken: 'refreshToken123' });\n\n      expect(response.status).toBe(200);\n      expect(response.body).toHaveProperty('message');\n    });\n\n    it('should return 400 for missing refresh token', async () => {\n      const response = await request(app)\n        .post('/logout')\n        .send({});\n\n      expect(response.status).toBe(400);\n    });\n  });\n\n  describe('POST /refresh', () => {\n    it('should refresh token successfully', async () => {\n      const refreshTokenDoc = {\n        token: 'refreshToken123',\n        userId: '123',\n        expiresAt: new Date(Date.now() + 86400000)\n      };\n      \n      RefreshToken.findOne.mockResolvedValue(refreshTokenDoc);\n      jwt.verify.mockReturnValue({ userId: '123', role: 'user' });\n      jwt.sign.mockReturnValue('newAccessToken');\n      RefreshToken.create.mockResolvedValue({ token: 'newRefreshToken' });\n\n      const response = await request(app)\n        .post('/refresh')\n        .send({ refreshToken: 'refreshToken123' });\n\n      expect(response.status).toBe(200);\n      expect(response.body).toHaveProperty('accessToken');\n      expect(response.body).toHaveProperty('refreshToken');\n    });\n\n    it('should return 401 for invalid refresh token', async () => {\n      RefreshToken.findOne.mockResolvedValue(null);\n\n      const response = await request(app)\n        .post('/refresh')\n        .send({ refreshToken: 'invalidToken' });\n\n      expect(response.status).toBe(401);\n    });\n\n    it('should return 401 for expired refresh token', async () => {\n      const expiredToken = {\n        token: 'refreshToken123',\n        userId: '123',\n        expiresAt: new Date(Date.now() - 86400000)\n      };\n      \n      RefreshToken.findOne.mockResolvedValue(expiredToken);\n\n      const response = await request(app)\n        .post('/refresh')\n        .send({ refreshToken: 'refreshToken123' });\n\n      expect(response.status).toBe(401);\n    });\n  });\n});\n"
    },
    {
      "file": "prova/codex_test/tests/middleware/authMiddleware.test.js",
      "operation": "create",
      "content": "const authMiddleware = require('../../middleware/authMiddleware');\nconst jwt = require('jsonwebtoken');\nconst User = require('../../models/User');\nconst BlacklistedToken = require('../../models/BlacklistedToken');\n\njest.mock('jsonwebtoken');\njest.mock('../../models/User');\njest.mock('../../models/BlacklistedToken');\n\ndescribe('Auth Middleware', () => {\n  let req, res, next;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    req = { headers: {} };\n    res = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn()\n    };\n    next = jest.fn();\n  });\n\n  describe('authenticateToken', () => {\n    it('should authenticate valid token', async () => {\n      req.headers.authorization = 'Bearer validToken';\n      jwt.verify.mockImplementation((token, secret, callback) => {\n        callback(null, { userId: '123', role: 'user' });\n      });\n      User.findById.mockResolvedValue({ _id: '123', role: 'user' });\n      BlacklistedToken.findOne.mockResolvedValue(null);\n\n      await authMiddleware.authenticateToken(req, res, next);\n\n      expect(req.user).toEqual({ userId: '123', role: 'user' });\n      expect(next).toHaveBeenCalled();\n    });\n\n    it('should return 401 for missing token', async () => {\n      await authMiddleware.authenticateToken(req, res, next);\n\n      expect(res.status).toHaveBeenCalledWith(401);\n      expect(res.json).toHaveBeenCalledWith({ message: 'Access token required' });\n      expect(next).not.toHaveBeenCalled();\n    });\n\n    it('should return 401 for invalid token', async () => {\n      req.headers.authorization = 'Bearer invalidToken';\n      jwt.verify.mockImplementation((token, secret, callback) => {\n        callback(new Error('Invalid token'), null);\n      });\n\n      await authMiddleware.authenticateToken(req, res, next);\n\n      expect(res.status).toHaveBeenCalledWith(401);\n      expect(res.json).toHaveBeenCalledWith({ message: 'Invalid or expired token' });\n      expect(next).not.toHaveBeenCalled();\n    });\n\n    it('should return 401 for blacklisted token', async () => {\n      req.headers.authorization = 'Bearer blacklistedToken';\n      jwt.verify.mockImplementation((token, secret, callback) => {\n        callback(null, { userId: '123', role: 'user' });\n      });\n      BlacklistedToken.findOne.mockResolvedValue({ token: 'blacklistedToken' });\n\n      await authMiddleware.authenticateToken(req, res, next);\n\n      expect(res.status).toHaveBeenCalledWith(401);\n      expect(res.json).toHaveBeenCalledWith({ message: 'Token has been revoked' });\n      expect(next).not.toHaveBeenCalled();\n    });\n\n    it('should return 401 for non-existent user', async () => {\n      req.headers.authorization = 'Bearer validToken';\n      jwt.verify.mockImplementation((token, secret, callback) => {\n        callback(null, { userId: 'nonexistent' });\n      });\n      User.findById.mockResolvedValue(null);\n\n      await authMiddleware.authenticateToken(req, res, next);\n\n      expect(res.status).toHaveBeenCalledWith(401);\n      expect(res.json).toHaveBeenCalledWith({ message: 'User not found' });\n      expect(next).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('requireRole', () => {\n    it('should allow user with required role', () => {\n      req.user = { role: 'admin' };\n      const middleware = authMiddleware.requireRole('admin');\n      \n      middleware(req, res, next);\n      \n      expect(next).toHaveBeenCalled();\n    });\n\n    it('should return 403 for user without required role', () => {\n      req.user = { role: 'user' };\n      const middleware = authMiddleware.requireRole('admin');\n      \n      middleware(req, res, next);\n      \n      expect(res.status).toHaveBeenCalledWith(403);\n      expect(res.json).toHaveBeenCalledWith({ message: 'Insufficient permissions' });\n      expect(next).not.toHaveBeenCalled();\n    });\n\n    it('should return 401 for missing user', () => {\n      const middleware = authMiddleware.requireRole('admin');\n      \n      middleware(req, res, next);\n      \n      expect(res.status).toHaveBeenCalledWith(401);\n      expect(res.json).toHaveBeenCalledWith({ message: 'Authentication required' });\n      expect(next).not.toHaveBeenCalled();\n    });\n  });\n});\n"
    },
    {
      "file": "prova/codex_test/tests/middleware/rateLimiter.test.js",
      "operation": "create",
      "content": "const rateLimiter = require('../../middleware/rateLimiter');\n\njest.useFakeTimers();\n\ndescribe('Rate Limiter Middleware', () => {\n  let req, res, next;\n\n  beforeEach(() => {\n    req = {\n      ip: '127.0.0.1',\n      headers: {}\n    };\n    res = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn()\n    };\n    next = jest.fn();\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n    rateLimiter.reset();\n  });\n\n  it('should allow requests under limit', () => {\n    for (let i = 0; i < 5; i++) {\n      rateLimiter.loginLimiter(req, res, next);\n      expect(next).toHaveBeenCalledTimes(i + 1);\n      expect(res.status).not.toHaveBeenCalled();\n    }\n  });\n\n  it('should block requests over limit', () => {\n    // Make 10 requests to exceed limit of 5\n    for (let i = 0; i < 10; i++) {\n      rateLimiter.loginLimiter(req, res, next);\n    }\n\n    // First 5 should pass\n    expect(next).toHaveBeenCalledTimes(5);\n    // Next 5 should be blocked\n    expect(res.status).toHaveBeenCalledWith(429);\n    expect(res.json).toHaveBeenCalledWith({\n      message: 'Too many login attempts, please try again later'\n    });\n  });\n\n  it('should reset after window time', () => {\n    // Exceed limit\n    for (let i = 0; i < 10; i++) {\n      rateLimiter.loginLimiter(req, res, next);\n    }\n\n    // Advance time by 15 minutes (900000 ms)\n    jest.advanceTimersByTime(900001);\n\n    // Next request should pass\n    rateLimiter.loginLimiter(req, res, next);\n    expect(next).toHaveBeenCalledTimes(6);\n    expect(res.status).toHaveBeenCalledTimes(5);\n  });\n\n  it('should use X-Forwarded-For header when available', () => {\n    req.headers['x-forwarded-for'] = '192.168.1.1';\n    \n    for (let i = 0; i < 5; i++) {\n      rateLimiter.loginLimiter(req, res, next);\n    }\n    \n    expect(next).toHaveBeenCalledTimes(5);\n  });\n\n  it('should handle multiple IPs independently', () => {\n    const req1 = { ip: '127.0.0.1', headers: {} };\n    const req2 = { ip: '127.0.0.2', headers: {} };\n    \n    // Fill up limit for first IP\n    for (let i = 0; i < 10; i++) {\n      rateLimiter.loginLimiter(req1, res, next);\n    }\n    \n    // Second IP should still work\n    for (let i = 0; i < 5; i++) {\n      rateLimiter.loginLimiter(req2, res, next);\n    }\n    \n    expect(next).toHaveBeenCalledTimes(10); // 5 for each IP\n    expect(res.status).toHaveBeenCalledTimes(5); // 5 blocked for first IP\n  });\n});\n"
    },
    {
      "file": "prova/codex_test/tests/utils/passwordUtils.test.js",
      "operation": "create",
      "content": "const bcrypt = require('bcrypt');\nconst { hashPassword, validatePassword } = require('../../utils/passwordUtils');\n\njest.mock('bcrypt');\n\ndescribe('Password Utils', () => {\n  describe('hashPassword', () => {\n    it('should hash password correctly', async () => {\n      bcrypt.hash.mockResolvedValue('hashedPassword123');\n      \n      const result = await hashPassword('myPassword123');\n      \n      expect(result).toBe('hashedPassword123');\n      expect(bcrypt.hash).toHaveBeenCalledWith('myPassword123', 12);\n    });\n\n    it('should reject with error when hashing fails', async () => {\n      bcrypt.hash.mockRejectedValue(new Error('Hashing failed'));\n      \n      await expect(hashPassword('myPassword123')).rejects.toThrow('Hashing failed');\n    });\n  });\n\n  describe('validatePassword', () => {\n    it('should validate correct password', async () => {\n      bcrypt.compare.mockResolvedValue(true);\n      \n      const result = await validatePassword('myPassword123', 'hashedPassword123');\n      \n      expect(result).toBe(true);\n      expect(bcrypt.compare).toHaveBeenCalledWith('myPassword123', 'hashedPassword123');\n    });\n\n    it('should reject invalid password', async () => {\n      bcrypt.compare.mockResolvedValue(false);\n      \n      const result = await validatePassword('wrongPassword', 'hashedPassword123');\n      \n      expect(result).toBe(false);\n    });\n\n    it('should reject with error when comparison fails', async () => {\n      bcrypt.compare.mockRejectedValue(new Error('Comparison failed'));\n      \n      await expect(validatePassword('myPassword123', 'hashedPassword123')).rejects.toThrow('Comparison failed');\n    });\n  });\n\n  describe('Password Security', () => {\n    it('should handle empty password', async () => {\n      bcrypt.hash.mockResolvedValue('hashedEmpty');\n      \n      const result = await hashPassword('');\n      \n      expect(result).toBe('hashedEmpty');\n    });\n\n    it('should handle very long password', async () => {\n      const longPassword = 'a'.repeat(1000);\n      bcrypt.hash.mockResolvedValue('hashedLong');\n      \n      const result = await hashPassword(longPassword);\n      \n      expect(result).toBe('hashedLong');\n    });\n\n    it('should handle special characters', async () => {\n      const specialPassword = 'P@ssw0rd!#$%';\n      bcrypt.hash.mockResolvedValue('hashedSpecial');\n      bcrypt.compare.mockResolvedValue(true);\n      \n      const hashed = await hashPassword(specialPassword);\n      const isValid = await validatePassword(specialPassword, hashed);\n      \n      expect(hashed).toBe('hashedSpecial');\n      expect(isValid).toBe(true);\n    });\n  });\n});\n"
    },
    {
      "file": "prova/codex_test/tests/utils/tokenUtils.test.js",
      "operation": "create",
      "content": "const jwt = require('jsonwebtoken');\nconst { v4: uuidv4 } = require('uuid');\nconst BlacklistedToken = require('../../models/BlacklistedToken');\nconst RefreshToken = require('../../models/RefreshToken');\nconst {\n  generateAccessToken,\n  generateRefreshToken,\n  verifyAccessToken,\n  verifyRefreshToken,\n  blacklistToken,\n  isTokenBlacklisted\n} = require('../../utils/tokenUtils');\n\njest.mock('jsonwebtoken');\njest.mock('uuid');\njest.mock('../../models/BlacklistedToken');\njest.mock('../../models/RefreshToken');\n\ndescribe('Token Utils', () => {\n  const mockUser = { _id: '123', email: 'test@example.com', role: 'user' };\n  \n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('generateAccessToken', () => {\n    it('should generate access token', () => {\n      jwt.sign.mockReturnValue('accessToken123');\n      \n      const token = generateAccessToken(mockUser);\n      \n      expect(token).toBe('accessToken123');\n      expect(jwt.sign).toHaveBeenCalledWith(\n        { userId: '123', email: 'test@example.com', role: 'user' },\n        process.env.JWT_ACCESS_SECRET,\n        { expiresIn: '15m' }\n      );\n    });\n\n    it('should use default secret when env not set', () => {\n      const originalSecret = process.env.JWT_ACCESS_SECRET;\n      delete process.env.JWT_ACCESS_SECRET;\n      \n      jwt.sign.mockReturnValue('accessToken123');\n      \n      const token = generateAccessToken(mockUser);\n      \n      expect(token).toBe('accessToken123');\n      expect(jwt.sign).toHaveBeenCalledWith(\n        expect.any(Object),\n        'fallback_access_secret',\n        expect.any(Object)\n      );\n      \n      process.env.JWT_ACCESS_SECRET = originalSecret;\n    });\n  });\n\n  describe('generateRefreshToken', () => {\n    it('should generate refresh token', () => {\n      uuidv4.mockReturnValue('refreshToken123');\n      \n      const token = generateRefreshToken();\n      \n      expect(token).toBe('refreshToken123');\n      expect(uuidv4).toHaveBeenCalled();\n    });\n  });\n\n  describe('verifyAccessToken', () => {\n    it('should verify valid token', () => {\n      jwt.verify.mockImplementation((token, secret, callback) => {\n        callback(null, { userId: '123', role: 'user' });\n      });\n      \n      const result = verifyAccessToken('validToken');\n      \n      expect(result).toEqual({ userId: '123', role: 'user' });\n      expect(jwt.verify).toHaveBeenCalledWith('validToken', process.env.JWT_ACCESS_SECRET, expect.any(Function));\n    });\n\n    it('should throw error for invalid token', () => {\n      jwt.verify.mockImplementation((token, secret, callback) => {\n        callback(new Error('Invalid token'), null);\n      });\n      \n      expect(() => verifyAccessToken('invalidToken')).toThrow('Invalid token');\n    });\n  });\n\n  describe('verifyRefreshToken', () => {\n    it('should verify valid refresh token', async () => {\n      const tokenDoc = {\n        token: 'refreshToken123',\n        userId: '123',\n        expiresAt: new Date(Date.now() + 86400000)\n      };\n      \n      RefreshToken.findOne.mockResolvedValue(tokenDoc);\n      \n      const result = await verifyRefreshToken('refreshToken123');\n      \n      expect(result).toEqual(tokenDoc);\n      expect(RefreshToken.findOne).toHaveBeenCalledWith({ token: 'refreshToken123' });\n    });\n\n    it('should reject for non-existent token', async () => {\n      RefreshToken.findOne.mockResolvedValue(null);\n      \n      await expect(verifyRefreshToken('invalidToken')).rejects.toThrow('Invalid refresh token');\n    });\n\n    it('should reject for expired token', async () => {\n      const expiredToken = {\n        token: 'refreshToken123',\n        userId: '123',\n        expiresAt: new Date(Date.now() - 86400000)\n      };\n      \n      RefreshToken.findOne.mockResolvedValue(expiredToken);\n      \n      await expect(verifyRefreshToken('refreshToken123')).rejects.toThrow('Refresh token expired');\n    });\n\n    it('should handle database errors', async () => {\n      RefreshToken.findOne.mockRejectedValue(new Error('Database error'));\n      \n      await expect(verifyRefreshToken('refreshToken123')).rejects.toThrow('Database error');\n    });\n  });\n\n  describe('blacklistToken', () => {\n    it('should blacklist token successfully', async () => {\n      BlacklistedToken.create.mockResolvedValue({ token: 'blacklistedToken123' });\n      \n      await blacklistToken('token123');\n      \n      expect(BlacklistedToken.create).toHaveBeenCalledWith({\n        token: 'token123',\n        expiresAt: expect.any(Date)\n      });\n    });\n\n    it('should handle database errors when blacklisting', async () => {\n      BlacklistedToken.create.mockRejectedValue(new Error('Database error'));\n      \n      await expect(blacklistToken('token123')).rejects.toThrow('Database error');\n    });\n  });\n\n  describe('isTokenBlacklisted', () => {\n    it('should return true for blacklisted token', async () => {\n      BlacklistedToken.findOne.mockResolvedValue({ token: 'blacklistedToken123' });\n      \n      const result = await isTokenBlacklisted('token123');\n      \n      expect(result).toBe(true);\n      expect(BlacklistedToken.findOne).toHaveBeenCalledWith({ token: 'token123' });\n    });\n\n    it('should return false for non-blacklisted token', async () => {\n      BlacklistedToken.findOne.mockResolvedValue(null);\n      \n      const result = await isTokenBlacklisted('token123');\n      \n      expect(result).toBe(false);\n    });\n\n    it('should handle database errors', async () => {\n      BlacklistedToken.findOne.mockRejectedValue(new Error('Database error'));\n      \n      await expect(isTokenBlacklisted('token123')).rejects.toThrow('Database error');\n    });\n  });\n});\n"
    },
    {
      "file": "prova/codex_test/tests/utils/validators.test.js",
      "operation": "create",
      "content": "const { validateEmail, validatePassword } = require('../../utils/validators');\n\ndescribe('Validators', () => {\n  describe('validateEmail', () => {\n    it('should validate correct email', () => {\n      expect(validateEmail('test@example.com')).toBe(true);\n      expect(validateEmail('user.name+tag@domain.co.uk')).toBe(true);\n      expect(validateEmail('user123@test-domain.org')).toBe(true);\n    });\n\n    it('should reject invalid email', () => {\n      expect(validateEmail('invalid.email')).toBe(false);\n      expect(validateEmail('@example.com')).toBe(false);\n      expect(validateEmail('test@')).toBe(false);\n      expect(validateEmail('test.example.com')).toBe(false);\n      expect(validateEmail('')).toBe(false);\n      expect(validateEmail(null)).toBe(false);\n      expect(validateEmail(undefined)).toBe(false);\n    });\n\n    it('should reject email without domain', () => {\n      expect(validateEmail('test@.com')).toBe(false);\n      expect(validateEmail('test@com')).toBe(false);\n    });\n\n    it('should reject email with spaces', () => {\n      expect(validateEmail('test @example.com')).toBe(false);\n      expect(validateEmail('test@ example.com')).toBe(false);\n    });\n\n    it('should handle edge cases', () => {\n      expect(validateEmail('a@b.co')).toBe(true);\n      expect(validateEmail('very.long.email.address.with.subdomains@sub.domain.example.com')).toBe(true);\n      expect(validateEmail('test@localhost')).toBe(true);\n    });\n  });\n\n  describe('validatePassword', () => {\n    it('should validate correct password', () => {\n      expect(validatePassword('Password123!')).toBe(true);\n      expect(validatePassword('StrongPass123@')).toBe(true);\n      expect(validatePassword('MySecurePassword1!')).toBe(true);\n    });\n\n    it('should reject password without uppercase', () => {\n      expect(validatePassword('password123!')).toBe(false);\n    });\n\n    it('should reject password without lowercase', () => {\n      expect(validatePassword('PASSWORD123!')).toBe(false);\n    });\n\n    it('should reject password without number', () => {\n      expect(validatePassword('Password!')).toBe(false);\n    });\n\n    it('should reject password without special character', () => {\n      expect(validatePassword('Password123')).toBe(false);\n    });\n\n    it('should reject password too short', () => {\n      expect(validatePassword('Pass1!')).toBe(false);\n    });\n\n    it('should reject empty or invalid passwords', () => {\n      expect(validatePassword('')).toBe(false);\n      expect(validatePassword(null)).toBe(false);\n      expect(validatePassword(undefined)).toBe(false);\n    });\n\n    it('should validate password with various special characters', () => {\n      expect(validatePassword('Password123@')).toBe(true);\n      expect(validatePassword('Password123#')).toBe(true);\n      expect(validatePassword('Password123$')).toBe(true);\n      expect(validatePassword('Password123%')).toBe(true);\n      expect(validatePassword('Password123^')).toBe(true);\n      expect(validatePassword('Password123&')).toBe(true);\n      expect(validatePassword('Password123*')).toBe(true);\n    });\n\n    it('should handle edge cases', () => {\n      expect(validatePassword('Aa1!')).toBe(false); // Too short\n      expect(validatePassword('A'.repeat(50) + 'a1!')).toBe(true); // Long password\n      expect(validatePassword('ValidPass123!@#')).toBe(true);\n    });\n  });\n});\n"
    },
    {
      "file": "prova/codex_test/tests/models/User.test.js",
      "operation": "create",
      "content": "const mongoose = require('mongoose');\nconst User = require('../../models/User');\n\ndescribe('User Model', () => {\n  beforeAll(async () => {\n    await mongoose.connect('mongodb://localhost:27017/test', {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    });\n  });\n\n  afterAll(async () => {\n    await mongoose.connection.dropDatabase();\n    await mongoose.connection.close();\n  });\n\n  afterEach(async () => {\n    await User.deleteMany({});\n  });\n\n  it('should create and save user successfully', async () => {\n    const userData = {\n      email: 'test@example.com',\n      password: 'hashedPassword123',\n      name: 'Test User',\n      role: 'user'\n    };\n\n    const user = new User(userData);\n    const savedUser = await user.save();\n\n    expect(savedUser._id).toBeDefined();\n    expect(savedUser.email).toBe(userData.email);\n    expect(savedUser.password).toBe(userData.password);\n    expect(savedUser.name).toBe(userData.name);\n    expect(savedUser.role).toBe(userData.role);\n    expect(savedUser.createdAt).toBeDefined();\n    expect(savedUser.updatedAt).toBeDefined();\n  });\n\n  it('should fail to create user without required fields', async () => {\n    const userWithoutEmail = new User({\n      password: 'hashedPassword123',\n      name: 'Test User'\n    });\n\n    let err;\n    try {\n      await userWithoutEmail.save();\n    } catch (error) {\n      err = error;\n    }\n\n    expect(err).toBeInstanceOf(mongoose.Error.ValidationError);\n    expect(err.errors.email).toBeDefined();\n  });\n\n  it('should fail to create user with duplicate email', async () => {\n    const userData = {\n      email: 'duplicate@example.com',\n      password: 'hashedPassword123',\n      name: 'Test User'\n    };\n\n    await new User(userData).save();\n    \n    let err;\n    try {\n      await new User(userData).save();\n    } catch (error) {\n      err = error;\n    }\n\n    expect(err).toBeDefined();\n    expect(err.code).toBe(11000); // Duplicate key error\n  });\n\n  it('should enforce email format', async () => {\n    const invalidUser = new User({\n      email: 'invalid-email',\n      password: 'hashedPassword123',\n      name: 'Test User'\n    });\n\n    let err;\n    try {\n      await invalidUser.save();\n    } catch (error) {\n      err = error;\n    }\n\n    expect(err).toBeInstanceOf(mongoose.Error.ValidationError);\n    expect(err.errors.email).toBeDefined();\n  });\n\n  it('should set default role to user', async () => {\n    const user = new User({\n      email: 'test@example.com',\n      password: 'hashedPassword123',\n      name: 'Test User'\n    });\n\n    const savedUser = await user.save();\n    expect(savedUser.role).toBe('user');\n  });\n\n  it('should allow admin role', async () => {\n    const user = new User({\n      email: 'admin@example.com',\n      password: 'hashedPassword123',\n      name: 'Admin User',\n      role: 'admin'\n    });\n\n    const savedUser = await user.save();\n    expect(savedUser.role).toBe('admin');\n  });\n\n  it('should find user by email', async () => {\n    const userData = {\n      email: 'findme@example.com',\n      password: 'hashedPassword123',\n      name: 'Find Me User'\n    };\n\n    await new User(userData).save();\n    \n    const foundUser = await User.findOne({ email: userData.email });\n    \n    expect(foundUser).toBeDefined();\n    expect(foundUser.email).toBe(userData.email);\n  });\n\n  it('should update user successfully', async () => {\n    const user = new User({\n      email: 'update@example.com',\n      password: 'hashedPassword123',\n      name: 'Old Name'\n    });\n\n    const savedUser = await user.save();\n    \n    savedUser.name = 'New Name';\n    const updatedUser = await savedUser.save();\n    \n    expect(updatedUser.name).toBe('New Name');\n    expect(updatedUser.updatedAt).not.toEqual(updatedUser.createdAt);\n  });\n\n  it('should delete user successfully', async () => {\n    const user = new User({\n      email: 'delete@example.com',\n      password: 'hashedPassword12