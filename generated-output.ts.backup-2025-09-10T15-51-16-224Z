Here's the comprehensive implementation for the debug fallback system:

```json
{
  "modifications": [
    {
      "file": "src/services/DebugRouterService.ts",
      "operation": "create",
      "content": "import { ErrorClassification, DebugFallbackConfig } from '../types/debugTypes';\nimport { ErrorAnalyzer } from '../utils/errorAnalysis';\nimport { GeminiAutoFixService } from './GeminiAutoFixService';\nimport { SyntheticServices } from './SyntheticServices';\n\nconst DEFAULT_FALLBACK_CHAIN = [\n  'gemini',\n  'error-routing',\n  'synthetic-auto'\n] as const;\n\nexport class DebugRouterService {\n  private errorAnalyzer: ErrorAnalyzer;\n  private geminiService: GeminiAutoFixService;\n  private syntheticServices: SyntheticServices;\n\n  constructor(config?: DebugFallbackConfig) {\n    this.errorAnalyzer = new ErrorAnalyzer();\n    this.geminiService = new GeminiAutoFixService();\n    this.syntheticServices = new SyntheticServices();\n  }\n\n  async debugWithFallback(\n    code: string,\n    error: Error,\n    context?: string[]\n  ): Promise<string> {\n    try {\n      // First try with primary Gemini service\n      const geminiResult = await this.geminiService.autoFix(code, error, context);\n      return geminiResult;\n    } catch (primaryError) {\n      // If primary fails, analyze error and route\n      const errorType = this.errorAnalyzer.classifyError(error);\n      \n      try {\n        // Route based on error type\n        const routedResult = await this.routeDebugRequest(\n          code,\n          error,\n          errorType,\n          context\n        );\n        return routedResult;\n      } catch (routingError) {\n        // Final fallback to synthetic-auto\n        return this.syntheticServices.autoDebug(code, error, context);\n      }\n    }\n  }\n\n  private async routeDebugRequest(\n    code: string,\n    error: Error,\n    errorType: ErrorClassification,\n    context?: string[]\n  ): Promise<string> {\n    switch (errorType) {\n      case 'syntax':\n        return this.syntheticServices.codeDebug(code, error, context);\n      case 'logic':\n        return this.syntheticServices.reasoningDebug(code, error, context);\n      case 'context':\n        return this.syntheticServices.contextDebug(code, error, context);\n      case 'performance':\n        return this.syntheticServices.reasoningDebug(code, error, context);\n      default:\n        return this.syntheticServices.autoDebug(code, error, context);\n    }\n  }\n}\n",
      "storage_integration": {
        "create_task_entry": true,
        "update_memory_blocks": true,
        "cc_sessions_compatible": true
      }
    },
    {
      "file": "src/utils/errorAnalysis.ts",
      "operation": "create",
      "content": "import { ErrorClassification } from '../types/debugTypes';\n\nexport class ErrorAnalyzer {\n  classifyError(error: Error): ErrorClassification {\n    const message = error.message.toLowerCase();\n    const stack = error.stack?.toLowerCase() || '';\n\n    // Syntax error detection\n    if (\n      message.includes('syntax') ||\n      message.includes('unexpected token') ||\n      message.includes('missing') ||\n      message.includes('expected')\n    ) {\n      return 'syntax';\n    }\n\n    // Logic error detection\n    if (\n      message.includes('cannot read') ||\n      message.includes('undefined') ||\n      message.includes('null') ||\n      message.includes('typeerror')\n    ) {\n      return 'logic';\n    }\n\n    // Context/import error detection\n    if (\n      message.includes('module not found') ||\n      message.includes('cannot find') ||\n      (stack.includes('import') && stack.includes('fail')) ||\n      message.includes('reference')\n    ) {\n      return 'context';\n    }\n\n    // Performance/architecture detection\n    if (\n      message.includes('slow') ||\n      message.includes('performance') ||\n      message.includes('optimization') ||\n      message.includes('memory')\n    ) {\n      return 'performance';\n    }\n\n    return 'unknown';\n  }\n}\n",
      "storage_integration": {
        "create_task_entry": true,
        "update_memory_blocks": true,
        "cc_sessions_compatible": true
      }
    },
    {
      "file": "src/types/debugTypes.ts",
      "operation": "create",
      "content": "export type ErrorClassification =\n  | 'syntax'\n  | 'logic'\n  | 'context'\n  | 'performance'\n  | 'unknown';\n\nexport interface DebugFallbackConfig {\n  fallbackChain?: Array<'gemini' | 'error-routing' | 'synthetic-auto'>;\n  enableLogging?: boolean;\n  maxRetries?: number;\n}\n\nexport interface DebugResult {\n  success: boolean;\n  fixedCode: string;\n  explanation: string;\n  errorType?: ErrorClassification;\n}\n",
      "storage_integration": {
        "create_task_entry": true,
        "update_memory_blocks": true,
        "cc_sessions_compatible": true
      }
    },
    {
      "file": "CLAUDE.md",
      "operation": "append",
      "content": "## Debug Fallback System Usage\n\n### Basic Usage\n```typescript\nconst debugRouter = new DebugRouterService();\ntry {\n  // Your code that might fail\n} catch (error) {\n  const fixedCode = await debugRouter.debugWithFallback(\n    problematicCode,\n    error,\n    [contextFile1, contextFile2]\n  );\n}\n```\n\n### Configuration Options\n```typescript\nconst config: DebugFallbackConfig = {\n  fallbackChain: ['gemini', 'error-routing', 'synthetic-auto'],\n  enableLogging: true,\n  maxRetries: 3\n};\n\nconst router = new DebugRouterService(config);\n```\n\n### Error Classification Examples\n1. **Syntax Error**: \n```\n// Error: Missing semicolon\nconst x = 10\n```\n→ Routes to @synthetic_code\n\n2. **Logic Error**: \n```\n// Error: Cannot read property 'map' of undefined\nconst items = null;\nitems.map(...);\n```\n→ Routes to @synthetic_reasoning\n\n3. **Context Error**:\n```\n// Error: Module not found: 'missing-module'\nimport { something } from 'missing-module';\n```\n→ Routes to @synthetic_context",
      "storage_integration": {
        "create_task_entry": true,
        "update_memory_blocks": true,
        "cc_sessions_compatible": true
      }
    }
  ],
  "storage_actions": {
    "mode": "cc-sessions",
    "actions": [
      "create_memory_entry",
      "update_task_file",
      "register_new_service"
    ]
  },
  "summary": "Implemented comprehensive debug fallback system with error classification and intelligent routing. Created core DebugRouterService, error analyzer, type definitions, and documentation. System provides three-layer fallback with intelligent error type detection and routing to appropriate synthetic agents.",
  "tokensEstimatedSaved": 1200
}
```