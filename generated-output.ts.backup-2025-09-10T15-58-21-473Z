```json
{
  "modifications": [
    {
      "file": "packages/core/src/ml/BackupManagerService.ts",
      "operation": "create",
      "content": "import fs from 'fs';\nimport path from 'path';\nimport { promisify } from 'util';\n\nconst mkdir = promisify(fs.mkdir);\nconst writeFile = promisify(fs.writeFile);\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst unlink = promisify(fs.unlink);\nconst rmdir = promisify(fs.rmdir);\n\nexport class BackupManagerService {\n  private static instance: BackupManagerService;\n  private backupBasePath: string;\n  private retentionHours: number;\n\n  private constructor() {\n    this.backupBasePath = process.env.BACKUP_BASE_PATH || '/tmp/devflow-backups';\n    this.retentionHours = parseInt(process.env.BACKUP_RETENTION_HOURS || '24', 10);\n  }\n\n  public static getInstance(): BackupManagerService {\n    if (!BackupManagerService.instance) {\n      BackupManagerService.instance = new BackupManagerService();\n    }\n    return BackupManagerService.instance;\n  }\n\n  public async createBackup(filePath: string, content: string): Promise<string> {\n    try {\n      const timestamp = new Date();\n      const datePath = `${timestamp.getFullYear()}-${(timestamp.getMonth() + 1).toString().padStart(2, '0')}-${timestamp.getDate().toString().padStart(2, '0')}`;\n      const timePath = `${timestamp.getHours().toString().padStart(2, '0')}-${timestamp.getMinutes().toString().padStart(2, '0')}-${timestamp.getSeconds().toString().padStart(2, '0')}`;\n      \n      const backupDir = path.join(this.backupBasePath, datePath, timePath);\n      await mkdir(backupDir, { recursive: true });\n      \n      const fileName = path.basename(filePath);\n      const backupFilePath = path.join(backupDir, `${fileName}.backup`);\n      \n      await writeFile(backupFilePath, content, 'utf8');\n      \n      // Create metadata file\n      const metadata = {\n        originalPath: filePath,\n        backupTime: timestamp.toISOString(),\n        size: content.length\n      };\n      \n      await writeFile(path.join(backupDir, 'metadata.json'), JSON.stringify(metadata, null, 2));\n      \n      return backupFilePath;\n    } catch (error) {\n      throw new Error(`Failed to create backup: ${error.message}`);\n    }\n  }\n\n  public async cleanupOldBackups(): Promise<void> {\n    try {\n      const cutoffTime = Date.now() - (this.retentionHours * 60 * 60 * 1000);\n      \n      if (!fs.existsSync(this.backupBasePath)) {\n        return;\n      }\n      \n      const dateDirs = await readdir(this.backupBasePath);\n      \n      for (const dateDir of dateDirs) {\n        const datePath = path.join(this.backupBasePath, dateDir);\n        const dateStat = await stat(datePath);\n        \n        if (dateStat.isDirectory()) {\n          // Parse date from directory name\n          const dateMatch = dateDir.match(/(\\d{4})-(\\d{2})-(\\d{2})/);\n          if (dateMatch) {\n            const [_, year, month, day] = dateMatch;\n            const dirDate = new Date(\n              parseInt(year, 10),\n              parseInt(month, 10) - 1, // Month is 0-indexed in JS\n              parseInt(day, 10)\n            );\n            \n            if (dirDate.getTime() < cutoffTime) {\n              await this.removeDirectory(datePath);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      throw new Error(`Failed to cleanup old backups: ${error.message}`);\n    }\n  }\n\n  private async removeDirectory(dirPath: string): Promise<void> {\n    const entries = await readdir(dirPath);\n    \n    for (const entry of entries) {\n      const entryPath = path.join(dirPath, entry);\n      const entryStat = await stat(entryPath);\n      \n      if (entryStat.isDirectory()) {\n        await this.removeDirectory(entryPath);\n      } else {\n        await unlink(entryPath);\n      }\n    }\n    \n    await rmdir(dirPath);\n  }\n\n  public getBackupBasePath(): string {\n    return this.backupBasePath;\n  }\n\n  public getRetentionHours(): number {\n    return this.retentionHours;\n  }\n}\n",
      "storage_integration": {
        "create_task_entry": true,
        "update_memory_blocks": true,
        "cc_sessions_compatible": true
      }
    },
    {
      "file": "packages/core/src/services/DebugRouterService.ts",
      "operation": "patch",
      "content": "import { BackupManagerService } from '../ml/BackupManagerService';\n\nexport class DebugRouterService {\n  private backupManager: BackupManagerService;\n\n  constructor() {\n    this.backupManager = BackupManagerService.getInstance();\n  }\n\n  async handleDebugRequest(filePath: string, content: string) {\n    // Create backup before processing debug request\n    try {\n      const backupPath = await this.backupManager.createBackup(filePath, content);\n      console.log(`Backup created at: ${backupPath}`);\n    } catch (error) {\n      console.error('Failed to create backup:', error);\n    }\n\n    // Existing debug logic...\n  }\n}",
      "storage_integration": {
        "create_task_entry": true,
        "update_memory_blocks": true,
        "cc_sessions_compatible": true
      }
    },
    {
      "file": "packages/core/src/services/GeminiAutoFixService.ts",
      "operation": "patch",
      "content": "import { BackupManagerService } from '../ml/BackupManagerService';\n\nexport class GeminiAutoFixService {\n  private backupManager: BackupManagerService;\n\n  constructor() {\n    this.backupManager = BackupManagerService.getInstance();\n  }\n\n  async applyFixes(filePath: string, originalContent: string, fixedContent: string) {\n    // Create backup before applying fixes\n    try {\n      const backupPath = await this.backupManager.createBackup(filePath, originalContent);\n      console.log(`Backup created at: ${backupPath}`);\n    } catch (error) {\n      console.error('Failed to create backup:', error);\n    }\n\n    // Apply fixes logic...\n  }\n}",
      "storage_integration": {
        "create_task_entry": true,
        "update_memory_blocks": true,
        "cc_sessions_compatible": true
      }
    },
    {
      "file": ".gitignore",
      "operation": "append",
      "content": "\n# DevFlow Backup Files\n/tmp/devflow-backups/\n*.backup\nbackup/\nbackups/\n",
      "storage_integration": {
        "create_task_entry": true,
        "update_memory_blocks": true,
        "cc_sessions_compatible": true
      }
    }
  ],
  "storage_actions": {
    "mode": "cc-sessions",
    "actions": ["create_memory_entry", "update_task_file"]
  },
  "summary": "Implemented intelligent backup management strategy with BackupManagerService, integrated with DebugRouterService and GeminiAutoFixService. Added backup patterns to .gitignore and created cleanup functionality for old backups.",
  "tokensEstimatedSaved": 800
}
```