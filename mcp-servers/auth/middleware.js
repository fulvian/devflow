/**
 * MCP Authentication Middleware
 * Generated by Synthetic AI for DEVFLOW-MCP-AUTH-002
 * 
 * Comprehensive authentication middleware for MCP servers including:
 * - JWT token validation
 * - API key authentication
 * - Rate limiting
 * - WebSocket session management
 * - Audit logging
 */

const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const crypto = require('crypto');
const { WebSocket } = require('ws');

class MCPAuthMiddleware {
  constructor(config) {
    this.config = {
      jwtSecret: process.env.JWT_SECRET || config.jwtSecret,
      apiKeyHeader: config.apiKeyHeader || 'x-api-key',
      rateLimitWindowMs: config.rateLimitWindowMs || 15 * 60 * 1000, // 15 minutes
      rateLimitMax: config.rateLimitMax || 100, // limit each IP to 100 requests per windowMs
      sessionTimeout: config.sessionTimeout || 3600000, // 1 hour
      auditLogPath: config.auditLogPath || './audit.log',
      ...config
    };

    this.activeSessions = new Map();
    this.apiKeys = new Map();
    this.rateLimiter = this.createRateLimiter();
    this.auditLogger = this.createAuditLogger();
  }

  /**
   * Create rate limiter middleware
   */
  createRateLimiter() {
    return rateLimit({
      windowMs: this.config.rateLimitWindowMs,
      max: this.config.rateLimitMax,
      message: {
        error: 'Too many requests, please try again later.',
        code: 'RATE_LIMIT_EXCEEDED'
      },
      standardHeaders: true,
      legacyHeaders: false,
    });
  }

  /**
   * Create audit logger
   */
  createAuditLogger() {
    const fs = require('fs');
    return {
      log: (event, details) => {
        const logEntry = {
          timestamp: new Date().toISOString(),
          event,
          details
        };
        
        fs.appendFileSync(
          this.config.auditLogPath, 
          JSON.stringify(logEntry) + '\n'
        );
      }
    };
  }

  /**
   * Validate JWT token
   */
  validateJWT(token) {
    try {
      const decoded = jwt.verify(token, this.config.jwtSecret);
      return { valid: true, payload: decoded };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  /**
   * Validate API key
   */
  validateAPIKey(apiKey) {
    if (!apiKey) return { valid: false, error: 'API key missing' };
    
    const keyData = this.apiKeys.get(apiKey);
    if (!keyData) return { valid: false, error: 'Invalid API key' };
    
    // Check if key is expired
    if (keyData.expiresAt && new Date() > keyData.expiresAt) {
      this.apiKeys.delete(apiKey);
      return { valid: false, error: 'API key expired' };
    }
    
    return { valid: true, payload: keyData };
  }

  /**
   * Generate session ID
   */
  generateSessionId() {
    return crypto.randomBytes(32).toString('hex');
  }

  /**
   * Create new session
   */
  createSession(userData) {
    const sessionId = this.generateSessionId();
    const session = {
      id: sessionId,
      userId: userData.id,
      createdAt: new Date(),
      lastAccessed: new Date(),
      expiresAt: new Date(Date.now() + this.config.sessionTimeout)
    };
    
    this.activeSessions.set(sessionId, session);
    return session;
  }

  /**
   * Validate session
   */
  validateSession(sessionId) {
    if (!sessionId) return { valid: false, error: 'Session ID missing' };
    
    const session = this.activeSessions.get(sessionId);
    if (!session) return { valid: false, error: 'Invalid session' };
    
    // Check if session is expired
    if (new Date() > session.expiresAt) {
      this.activeSessions.delete(sessionId);
      return { valid: false, error: 'Session expired' };
    }
    
    // Update last accessed time
    session.lastAccessed = new Date();
    return { valid: true, session };
  }

  /**
   * JWT Authentication Middleware
   */
  jwtAuth() {
    return (req, res, next) => {
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        this.auditLogger.log('AUTH_FAILURE', {
          ip: req.ip,
          method: req.method,
          url: req.url,
          reason: 'Missing or invalid authorization header'
        });
        
        return res.status(401).json({
          error: 'Unauthorized',
          message: 'Missing or invalid authorization header'
        });
      }

      const token = authHeader.substring(7);
      const result = this.validateJWT(token);
      
      if (!result.valid) {
        this.auditLogger.log('AUTH_FAILURE', {
          ip: req.ip,
          method: req.method,
          url: req.url,
          reason: 'Invalid JWT token',
          error: result.error
        });
        
        return res.status(401).json({
          error: 'Unauthorized',
          message: 'Invalid or expired token'
        });
      }

      req.user = result.payload;
      req.authType = 'jwt';
      
      this.auditLogger.log('AUTH_SUCCESS', {
        userId: result.payload.id,
        ip: req.ip,
        method: req.method,
        url: req.url,
        authType: 'jwt'
      });
      
      next();
    };
  }

  /**
   * API Key Authentication Middleware
   */
  apiKeyAuth() {
    return (req, res, next) => {
      const apiKey = req.headers[this.config.apiKeyHeader.toLowerCase()];
      const result = this.validateAPIKey(apiKey);
      
      if (!result.valid) {
        this.auditLogger.log('AUTH_FAILURE', {
          ip: req.ip,
          method: req.method,
          url: req.url,
          reason: 'Invalid API key',
          error: result.error
        });
        
        return res.status(401).json({
          error: 'Unauthorized',
          message: result.error
        });
      }

      req.user = result.payload;
      req.authType = 'api_key';
      
      this.auditLogger.log('AUTH_SUCCESS', {
        userId: result.payload.userId,
        ip: req.ip,
        method: req.method,
        url: req.url,
        authType: 'api_key'
      });
      
      next();
    };
  }

  /**
   * Session Authentication Middleware
   */
  sessionAuth() {
    return (req, res, next) => {
      const sessionId = req.headers['x-session-id'];
      const result = this.validateSession(sessionId);
      
      if (!result.valid) {
        this.auditLogger.log('AUTH_FAILURE', {
          ip: req.ip,
          method: req.method,
          url: req.url,
          reason: 'Invalid session',
          error: result.error
        });
        
        return res.status(401).json({
          error: 'Unauthorized',
          message: result.error
        });
      }

      req.user = { id: result.session.userId };
      req.session = result.session;
      req.authType = 'session';
      
      this.auditLogger.log('AUTH_SUCCESS', {
        userId: result.session.userId,
        sessionId: result.session.id,
        ip: req.ip,
        method: req.method,
        url: req.url,
        authType: 'session'
      });
      
      next();
    };
  }

  /**
   * WebSocket Authentication
   */
  websocketAuth() {
    return (ws, req) => {
      // Handle JWT authentication for WebSocket
      const authHeader = req.headers.authorization;
      if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.substring(7);
        const result = this.validateJWT(token);
        
        if (result.valid) {
          ws.user = result.payload;
          ws.authType = 'jwt';
          
          this.auditLogger.log('WEBSOCKET_AUTH_SUCCESS', {
            userId: result.payload.id,
            ip: req.socket.remoteAddress,
            authType: 'jwt'
          });
          
          return true;
        }
      }
      
      // Handle API key authentication for WebSocket
      const apiKey = req.headers[this.config.apiKeyHeader.toLowerCase()];
      if (apiKey) {
        const result = this.validateAPIKey(apiKey);
        if (result.valid) {
          ws.user = result.payload;
          ws.authType = 'api_key';
          
          this.auditLogger.log('WEBSOCKET_AUTH_SUCCESS', {
            userId: result.payload.userId,
            ip: req.socket.remoteAddress,
            authType: 'api_key'
          });
          
          return true;
        }
      }
      
      // Handle session authentication for WebSocket
      const sessionId = req.headers['x-session-id'];
      if (sessionId) {
        const result = this.validateSession(sessionId);
        if (result.valid) {
          ws.user = { id: result.session.userId };
          ws.session = result.session;
          ws.authType = 'session';
          
          this.auditLogger.log('WEBSOCKET_AUTH_SUCCESS', {
            userId: result.session.userId,
            sessionId: result.session.id,
            ip: req.socket.remoteAddress,
            authType: 'session'
          });
          
          return true;
        }
      }
      
      this.auditLogger.log('WEBSOCKET_AUTH_FAILURE', {
        ip: req.socket.remoteAddress,
        reason: 'No valid authentication provided'
      });
      
      return false;
    };
  }

  /**
   * Session cleanup task
   */
  cleanupExpiredSessions() {
    const now = new Date();
    let count = 0;
    
    for (const [sessionId, session] of this.activeSessions.entries()) {
      if (now > session.expiresAt) {
        this.activeSessions.delete(sessionId);
        count++;
      }
    }
    
    if (count > 0) {
      this.auditLogger.log('SESSION_CLEANUP', {
        expiredSessions: count
      });
    }
    
    return count;
  }

  /**
   * Start session cleanup interval
   */
  startSessionCleanup() {
    setInterval(() => {
      this.cleanupExpiredSessions();
    }, this.config.sessionTimeout / 2);
  }

  /**
   * Register API key
   */
  registerAPIKey(apiKey, userData) {
    this.apiKeys.set(apiKey, {
      ...userData,
      createdAt: new Date(),
      expiresAt: userData.expiresAt ? new Date(userData.expiresAt) : null
    });
  }

  /**
   * Revoke API key
   */
  revokeAPIKey(apiKey) {
    return this.apiKeys.delete(apiKey);
  }

  /**
   * Get rate limiter middleware
   */
  getRateLimiter() {
    return this.rateLimiter;
  }

  /**
   * Get audit logger
   */
  getAuditLogger() {
    return this.auditLogger;
  }
}

module.exports = MCPAuthMiddleware;