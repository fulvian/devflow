/**
 * Platform Handoff Engine for DevFlow
 * Generates handoff commands and preserves context across platforms
 */

import type { HandoffContext, Platform } from '@devflow/shared';

export interface HandoffCommand {
  command: string;
  context: string;
  platform: Platform;
  metadata: {
    timestamp: Date;
    taskId?: string;
    sessionId?: string;
  };
}

export class PlatformHandoffEngine {
  private readonly platformConfigs: Record<Platform, PlatformConfig>;

  constructor() {
    this.platformConfigs = {
      openai_codex: {
        name: 'OpenAI Codex',
        commandPrefix: 'codex',
        contextFormat: 'markdown',
        specializations: ['implementation', 'bulk_coding', 'pattern_following'],
        handoffTemplate: this.getCodexHandoffTemplate(),
      },
      synthetic: {
        name: 'Synthetic.new',
        commandPrefix: 'synthetic',
        contextFormat: 'structured',
        specializations: ['rapid_prototyping', 'code_generation', 'debugging'],
        handoffTemplate: this.getSyntheticHandoffTemplate(),
      },
      gemini: {
        name: 'Google Gemini',
        commandPrefix: 'gemini',
        contextFormat: 'conversational',
        specializations: ['reasoning', 'analysis', 'documentation'],
        handoffTemplate: this.getGeminiHandoffTemplate(),
      },
      cursor: {
        name: 'Cursor IDE',
        commandPrefix: 'cursor',
        contextFormat: 'ide_context',
        specializations: ['refactoring', 'maintenance', 'code_review'],
        handoffTemplate: this.getCursorHandoffTemplate(),
      },
      claude_code: {
        name: 'Claude Code',
        commandPrefix: 'claude-code',
        contextFormat: 'architectural',
        specializations: ['architecture', 'complex_reasoning', 'system_design'],
        handoffTemplate: this.getClaudeCodeHandoffTemplate(),
      },
      openrouter: {
        name: 'OpenRouter Gateway',
        commandPrefix: 'openrouter',
        contextFormat: 'api_context',
        specializations: ['model_routing', 'cost_optimization', 'multi_model'],
        handoffTemplate: this.getOpenRouterHandoffTemplate(),
      },
      codex: {
        name: 'Codex',
        commandPrefix: 'codex',
        contextFormat: 'json',
        specializations: ['implementation', 'bulk_coding', 'pattern_following'],
        handoffTemplate: this.getCodexHandoffTemplate(),
      },
      gemini_cli: {
        name: 'Gemini CLI',
        commandPrefix: 'gemini-cli',
        contextFormat: 'markdown',
        specializations: ['reasoning', 'analysis', 'documentation'],
        handoffTemplate: this.getGeminiHandoffTemplate(),
      },
    } as any;
  }

  async generateHandoffCommand(handoffContext: HandoffContext): Promise<string> {
    const config = this.platformConfigs[handoffContext.platform];
    if (!config) {
      throw new Error(`Unsupported platform: ${handoffContext.platform}`);
    }

    const command = this.buildHandoffCommand(handoffContext, config);
    return command;
  }

  private buildHandoffCommand(context: HandoffContext, config: PlatformConfig): string {
    const template = config.handoffTemplate;
    
    return template
      .replace('{{PLATFORM_NAME}}', config.name)
      .replace('{{TASK}}', context.task)
      .replace('{{CONTEXT}}', context.context || '')
      .replace('{{PRESERVE_ARCHITECTURE}}', context.preserveArchitecture ? 'YES' : 'NO')
      .replace('{{TIMESTAMP}}', context.timestamp.toISOString())
      .replace('{{SPECIALIZATIONS}}', config.specializations.join(', '));
  }

  private getCodexHandoffTemplate(): string {
    return `# DevFlow Handoff to OpenAI Codex

## Task
{{TASK}}

## Context
{{CONTEXT}}

## Architectural Decisions Preserved
{{PRESERVE_ARCHITECTURE}}

## Implementation Guidelines
- Follow established patterns from DevFlow memory
- Maintain architectural consistency
- Implement with focus on: {{SPECIALIZATIONS}}
- Use TypeScript strict mode
- Follow DevFlow coding standards

## DevFlow Memory Context
This handoff includes preserved architectural decisions and implementation patterns from previous DevFlow sessions. All context has been automatically prepared by DevFlow Universal Development State Manager.

## Next Steps
1. Review architectural context above
2. Implement following established patterns
3. Maintain consistency with DevFlow memory
4. Report progress back to DevFlow

---
*Handoff generated by DevFlow at {{TIMESTAMP}}*`;
  }

  private getSyntheticHandoffTemplate(): string {
    return `# DevFlow Handoff to Synthetic.new

## Task
{{TASK}}

## Context
{{CONTEXT}}

## Architectural Decisions Preserved
{{PRESERVE_ARCHITECTURE}}

## Synthetic.new Specializations
Focus on: {{SPECIALIZATIONS}}

## Implementation Approach
- Use rapid prototyping capabilities
- Generate clean, production-ready code
- Follow DevFlow architectural patterns
- Maintain type safety and best practices

## DevFlow Integration
- All architectural decisions preserved
- Context automatically prepared by DevFlow
- Maintain consistency with DevFlow memory
- Report implementation progress

## Code Generation Guidelines
- TypeScript with strict mode
- Follow DevFlow coding standards
- Implement with focus on performance
- Maintain architectural consistency

---
*Handoff generated by DevFlow at {{TIMESTAMP}}*`;
  }

  private getGeminiHandoffTemplate(): string {
    return `# DevFlow Handoff to Google Gemini

## Task
{{TASK}}

## Context
{{CONTEXT}}

## Architectural Decisions Preserved
{{PRESERVE_ARCHITECTURE}}

## Gemini Specializations
Focus on: {{SPECIALIZATIONS}}

## Analysis Approach
- Deep reasoning and analysis
- Comprehensive documentation
- Strategic thinking
- Complex problem solving

## DevFlow Context
- Architectural decisions preserved from DevFlow memory
- Context automatically prepared by DevFlow Universal Development State Manager
- Maintain consistency with established patterns

## Deliverables
- Detailed analysis and reasoning
- Comprehensive documentation
- Strategic recommendations
- Implementation guidance

---
*Handoff generated by DevFlow at {{TIMESTAMP}}*`;
  }

  private getCursorHandoffTemplate(): string {
    return `# DevFlow Handoff to Cursor IDE

## Task
{{TASK}}

## Context
{{CONTEXT}}

## Architectural Decisions Preserved
{{PRESERVE_ARCHITECTURE}}

## Cursor Specializations
Focus on: {{SPECIALIZATIONS}}

## IDE Integration
- Refactoring and code maintenance
- Code review and quality assurance
- IDE-specific optimizations
- Development workflow improvements

## DevFlow Memory Integration
- All architectural decisions preserved
- Context automatically prepared by DevFlow
- Maintain consistency with DevFlow patterns
- Follow established coding standards

## Implementation Guidelines
- Use IDE features for efficient development
- Maintain code quality and consistency
- Follow DevFlow architectural patterns
- Report progress to DevFlow

---
*Handoff generated by DevFlow at {{TIMESTAMP}}*`;
  }

  private getClaudeCodeHandoffTemplate(): string {
    return `# DevFlow Handoff to Claude Code

## Task
{{TASK}}

## Context
{{CONTEXT}}

## Architectural Decisions Preserved
{{PRESERVE_ARCHITECTURE}}

## Claude Code Specializations
Focus on: {{SPECIALIZATIONS}}

## Architectural Approach
- Complex system design and architecture
- Strategic planning and reasoning
- High-level system analysis
- Architectural decision making

## DevFlow Memory Context
- All previous architectural decisions preserved
- Context automatically prepared by DevFlow Universal Development State Manager
- Maintain consistency with established patterns

## Next Steps
1. Review architectural context
2. Plan system architecture
3. Make strategic decisions
4. Document architectural patterns

---
*Handoff generated by DevFlow at {{TIMESTAMP}}*`;
  }

  private getOpenRouterHandoffTemplate(): string {
    return `# DevFlow Handoff to OpenRouter Gateway

## Task
{{TASK}}

## Context
{{CONTEXT}}

## Architectural Decisions Preserved
{{PRESERVE_ARCHITECTURE}}

## OpenRouter Specializations
Focus on: {{SPECIALIZATIONS}}

## Multi-Model Approach
- Intelligent model routing
- Cost optimization
- Multi-model coordination
- API efficiency

## DevFlow Integration
- All architectural decisions preserved
- Context automatically prepared by DevFlow
- Maintain consistency with DevFlow patterns
- Optimize for cost and performance

## Implementation Guidelines
- Use appropriate models for task type
- Optimize API usage and costs
- Maintain architectural consistency
- Report progress to DevFlow

---
*Handoff generated by DevFlow at {{TIMESTAMP}}*`;
  }

  getSupportedPlatforms(): Platform[] {
    return Object.keys(this.platformConfigs) as Platform[];
  }

  getPlatformCapabilities(platform: Platform): string[] {
    const config = this.platformConfigs[platform];
    return config ? config.specializations : [];
  }
}

interface PlatformConfig {
  name: string;
  commandPrefix: string;
  contextFormat: string;
  specializations: string[];
  handoffTemplate: string;
}
