/**
 * Conflict Resolver - Operational Transforms for Cross-Platform Memory
 * Generated by Synthetic Code Agent: DEVFLOW-MEMORY-001
 * Handles concurrent edits and version conflicts
 */
export class ConflictResolver {
    strategies = new Map();
    constructor() {
        this.registerDefaultStrategies();
    }
    registerDefaultStrategies() {
        // Last Writer Wins strategy
        this.strategies.set('last-writer-wins', {
            name: 'Last Writer Wins',
            resolve: (current, incoming) => {
                return {
                    ...incoming,
                    version: Math.max(current.version, incoming.version) + 1,
                    lastUpdated: new Date(),
                    metadata: {
                        ...current.metadata,
                        ...incoming.metadata,
                        conflictResolved: true,
                        strategy: 'last-writer-wins'
                    }
                };
            }
        });
        // Merge Strategy for object data
        this.strategies.set('merge', {
            name: 'Object Merge',
            resolve: (current, incoming) => {
                const mergedData = this.deepMerge(current.data, incoming.data);
                return {
                    ...current,
                    data: mergedData,
                    version: Math.max(current.version, incoming.version) + 1,
                    lastUpdated: new Date(),
                    metadata: {
                        ...current.metadata,
                        ...incoming.metadata,
                        conflictResolved: true,
                        strategy: 'merge',
                        originalVersions: [current.version, incoming.version]
                    }
                };
            }
        });
        // Version Vector strategy for complex conflicts
        this.strategies.set('version-vector', {
            name: 'Version Vector Resolution',
            resolve: (current, incoming) => {
                // Simple version vector implementation
                const currentTime = current.lastUpdated.getTime();
                const incomingTime = incoming.lastUpdated.getTime();
                // Use timestamp as tiebreaker
                const winner = incomingTime > currentTime ? incoming : current;
                const loser = incomingTime > currentTime ? current : incoming;
                return {
                    ...winner,
                    version: Math.max(current.version, incoming.version) + 1,
                    lastUpdated: new Date(),
                    data: this.deepMerge(winner.data, loser.data),
                    metadata: {
                        ...winner.metadata,
                        conflictResolved: true,
                        strategy: 'version-vector',
                        mergedFrom: [current.id, incoming.id]
                    }
                };
            }
        });
    }
    async resolve(current, incoming, strategyName = 'merge') {
        const strategy = this.strategies.get(strategyName);
        if (!strategy) {
            throw new Error(`Unknown conflict resolution strategy: ${strategyName}`);
        }
        console.log(`🔄 Resolving conflict for context ${current.id} using strategy: ${strategy.name}`);
        console.log(`   Current version: ${current.version}, Incoming version: ${incoming.version}`);
        try {
            const resolved = strategy.resolve(current, incoming);
            console.log(`✅ Conflict resolved: new version ${resolved.version}`);
            return resolved;
        }
        catch (error) {
            console.error(`❌ Conflict resolution failed with strategy ${strategy.name}:`, error);
            // Fallback to last-writer-wins
            const fallbackStrategy = this.strategies.get('last-writer-wins');
            console.log(`🔄 Using fallback strategy: ${fallbackStrategy.name}`);
            return fallbackStrategy.resolve(current, incoming);
        }
    }
    registerStrategy(name, strategy) {
        this.strategies.set(name, strategy);
        console.log(`📝 Registered conflict resolution strategy: ${name}`);
    }
    getAvailableStrategies() {
        return Array.from(this.strategies.keys());
    }
    deepMerge(target, source) {
        if (source === null || source === undefined)
            return target;
        if (target === null || target === undefined)
            return source;
        // Handle primitive types
        if (typeof source !== 'object' || typeof target !== 'object') {
            return source; // Source wins for primitives
        }
        // Handle arrays
        if (Array.isArray(source) && Array.isArray(target)) {
            return [...target, ...source.filter(item => !target.includes(item))];
        }
        if (Array.isArray(source) || Array.isArray(target)) {
            return source; // Source wins if types don't match
        }
        // Handle objects
        const result = { ...target };
        for (const key in source) {
            if (source.hasOwnProperty(key)) {
                if (result.hasOwnProperty(key)) {
                    result[key] = this.deepMerge(result[key], source[key]);
                }
                else {
                    result[key] = source[key];
                }
            }
        }
        return result;
    }
    detectConflictType(current, incoming) {
        if (current.version !== incoming.version) {
            return 'version';
        }
        if (JSON.stringify(current.data) !== JSON.stringify(incoming.data)) {
            return 'data';
        }
        if (JSON.stringify(current.metadata) !== JSON.stringify(incoming.metadata)) {
            return 'metadata';
        }
        return 'none';
    }
}
//# sourceMappingURL=conflict-resolver.js.map