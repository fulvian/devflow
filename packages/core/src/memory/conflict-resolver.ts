/**
 * Conflict Resolver - Operational Transforms for Cross-Platform Memory
 * Generated by Synthetic Code Agent: DEVFLOW-MEMORY-001
 * Handles concurrent edits and version conflicts
 */

import { UniversalContextFormat } from './universal-context-format.js';

export interface ConflictResolutionStrategy {
  name: string;
  resolve(current: UniversalContextFormat, incoming: UniversalContextFormat): UniversalContextFormat;
}

export class ConflictResolver {
  private strategies: Map<string, ConflictResolutionStrategy> = new Map();

  constructor() {
    this.registerDefaultStrategies();
  }

  private registerDefaultStrategies(): void {
    // Last Writer Wins strategy
    this.strategies.set('last-writer-wins', {
      name: 'Last Writer Wins',
      resolve: (current: UniversalContextFormat, incoming: UniversalContextFormat): UniversalContextFormat => {
        return {
          ...incoming,
          version: Math.max(current.version, incoming.version) + 1,
          lastUpdated: new Date(),
          metadata: {
            ...current.metadata,
            ...incoming.metadata,
            conflictResolved: true,
            strategy: 'last-writer-wins'
          }
        };
      }
    });

    // Merge Strategy for object data
    this.strategies.set('merge', {
      name: 'Object Merge',
      resolve: (current: UniversalContextFormat, incoming: UniversalContextFormat): UniversalContextFormat => {
        const mergedData = this.deepMerge(current.data, incoming.data);
        
        return {
          ...current,
          data: mergedData,
          version: Math.max(current.version, incoming.version) + 1,
          lastUpdated: new Date(),
          metadata: {
            ...current.metadata,
            ...incoming.metadata,
            conflictResolved: true,
            strategy: 'merge',
            originalVersions: [current.version, incoming.version]
          }
        };
      }
    });

    // Version Vector strategy for complex conflicts
    this.strategies.set('version-vector', {
      name: 'Version Vector Resolution',
      resolve: (current: UniversalContextFormat, incoming: UniversalContextFormat): UniversalContextFormat => {
        // Simple version vector implementation
        const currentTime = current.lastUpdated.getTime();
        const incomingTime = incoming.lastUpdated.getTime();
        
        // Use timestamp as tiebreaker
        const winner = incomingTime > currentTime ? incoming : current;
        const loser = incomingTime > currentTime ? current : incoming;
        
        return {
          ...winner,
          version: Math.max(current.version, incoming.version) + 1,
          lastUpdated: new Date(),
          data: this.deepMerge(winner.data, loser.data),
          metadata: {
            ...winner.metadata,
            conflictResolved: true,
            strategy: 'version-vector',
            mergedFrom: [current.id, incoming.id]
          }
        };
      }
    });
  }

  public async resolve(
    current: UniversalContextFormat, 
    incoming: UniversalContextFormat,
    strategyName: string = 'merge'
  ): Promise<UniversalContextFormat> {
    
    const strategy = this.strategies.get(strategyName);
    if (!strategy) {
      throw new Error(`Unknown conflict resolution strategy: ${strategyName}`);
    }

    console.log(`🔄 Resolving conflict for context ${current.id} using strategy: ${strategy.name}`);
    console.log(`   Current version: ${current.version}, Incoming version: ${incoming.version}`);
    
    try {
      const resolved = strategy.resolve(current, incoming);
      
      console.log(`✅ Conflict resolved: new version ${resolved.version}`);
      
      return resolved;
      
    } catch (error) {
      console.error(`❌ Conflict resolution failed with strategy ${strategy.name}:`, error);
      
      // Fallback to last-writer-wins
      const fallbackStrategy = this.strategies.get('last-writer-wins')!;
      console.log(`🔄 Using fallback strategy: ${fallbackStrategy.name}`);
      
      return fallbackStrategy.resolve(current, incoming);
    }
  }

  public registerStrategy(name: string, strategy: ConflictResolutionStrategy): void {
    this.strategies.set(name, strategy);
    console.log(`📝 Registered conflict resolution strategy: ${name}`);
  }

  public getAvailableStrategies(): string[] {
    return Array.from(this.strategies.keys());
  }

  private deepMerge(target: any, source: any): any {
    if (source === null || source === undefined) return target;
    if (target === null || target === undefined) return source;
    
    // Handle primitive types
    if (typeof source !== 'object' || typeof target !== 'object') {
      return source; // Source wins for primitives
    }

    // Handle arrays
    if (Array.isArray(source) && Array.isArray(target)) {
      return [...target, ...source.filter(item => !target.includes(item))];
    }

    if (Array.isArray(source) || Array.isArray(target)) {
      return source; // Source wins if types don't match
    }

    // Handle objects
    const result = { ...target };
    
    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        if (result.hasOwnProperty(key)) {
          result[key] = this.deepMerge(result[key], source[key]);
        } else {
          result[key] = source[key];
        }
      }
    }
    
    return result;
  }

  public detectConflictType(
    current: UniversalContextFormat, 
    incoming: UniversalContextFormat
  ): 'version' | 'data' | 'metadata' | 'none' {
    
    if (current.version !== incoming.version) {
      return 'version';
    }
    
    if (JSON.stringify(current.data) !== JSON.stringify(incoming.data)) {
      return 'data';
    }
    
    if (JSON.stringify(current.metadata) !== JSON.stringify(incoming.metadata)) {
      return 'metadata';
    }
    
    return 'none';
  }
}