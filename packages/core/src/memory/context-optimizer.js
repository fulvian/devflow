/**
 * Context Optimizer - Compression and Platform-specific Filtering
 * Generated by Synthetic Code Agent: DEVFLOW-MEMORY-001
 * Optimizes context for memory usage and platform requirements
 */
import * as zlib from 'zlib';
export class ContextOptimizer {
    defaultOptions = {
        compressionEnabled: true,
        maxDataSize: 100 * 1024, // 100KB max
        relevanceThreshold: 0.5
    };
    compress(context, options) {
        const opts = { ...this.defaultOptions, ...options };
        try {
            let optimizedData = context.data;
            // Apply platform-specific filtering
            if (opts.platformFilter) {
                optimizedData = this.filterForPlatform(optimizedData, opts.platformFilter);
            }
            // Apply size limits
            if (opts.maxDataSize) {
                optimizedData = this.limitDataSize(optimizedData, opts.maxDataSize);
            }
            // Apply compression
            if (opts.compressionEnabled) {
                const dataString = JSON.stringify(optimizedData);
                const compressedBuffer = zlib.gzipSync(dataString);
                const compressionRatio = compressedBuffer.length / Buffer.from(dataString).length;
                console.log(`🗜️  Compression ratio: ${(compressionRatio * 100).toFixed(1)}%`);
                return {
                    ...context,
                    data: compressedBuffer,
                    metadata: {
                        ...context.metadata,
                        compressed: true,
                        originalSize: Buffer.from(dataString).length,
                        compressedSize: compressedBuffer.length,
                        compressionRatio
                    }
                };
            }
            return {
                ...context,
                data: optimizedData,
                metadata: {
                    ...context.metadata,
                    compressed: false,
                    optimized: true
                }
            };
        }
        catch (error) {
            console.error('❌ Compression failed:', error);
            return context; // Return original if compression fails
        }
    }
    decompress(context) {
        try {
            if (context.metadata?.compressed) {
                const decompressedBuffer = zlib.gunzipSync(context.data);
                const decompressedData = JSON.parse(decompressedBuffer.toString());
                return {
                    ...context,
                    data: decompressedData,
                    metadata: {
                        ...context.metadata,
                        compressed: false,
                        decompressed: true
                    }
                };
            }
            return context; // Return as-is if not compressed
        }
        catch (error) {
            console.error('❌ Decompression failed:', error);
            throw new Error(`Failed to decompress context ${context.id}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    filterForPlatform(data, platform) {
        // Platform-specific filtering logic
        const platformFilters = {
            'synthetic': (data) => {
                // Keep relevant data for Synthetic.new
                return this.filterByRelevance(data, ['code', 'implementation', 'functions']);
            },
            'openrouter': (data) => {
                // Keep complex reasoning data for OpenRouter
                return this.filterByRelevance(data, ['architecture', 'analysis', 'reasoning']);
            },
            'claude-code': (data) => {
                // Keep architectural and coordination data
                return this.filterByRelevance(data, ['architecture', 'coordination', 'decisions']);
            }
        };
        const filter = platformFilters[platform];
        return filter ? filter(data) : data;
    }
    filterByRelevance(data, keywords) {
        if (typeof data !== 'object' || data === null) {
            return data;
        }
        if (Array.isArray(data)) {
            return data.map(item => this.filterByRelevance(item, keywords));
        }
        const filtered = {};
        for (const [key, value] of Object.entries(data)) {
            const keyLower = key.toLowerCase();
            const isRelevant = keywords.some(keyword => keyLower.includes(keyword.toLowerCase()) ||
                (typeof value === 'string' && value.toLowerCase().includes(keyword.toLowerCase())));
            if (isRelevant) {
                filtered[key] = typeof value === 'object' ? this.filterByRelevance(value, keywords) : value;
            }
        }
        return Object.keys(filtered).length > 0 ? filtered : data; // Return original if nothing relevant found
    }
    limitDataSize(data, maxSize) {
        const dataString = JSON.stringify(data);
        const currentSize = Buffer.from(dataString).length;
        if (currentSize <= maxSize) {
            return data;
        }
        console.log(`⚠️  Data size ${currentSize} bytes exceeds limit ${maxSize} bytes, applying size reduction`);
        // Simple size reduction: truncate arrays and strings
        return this.truncateData(data, maxSize / currentSize);
    }
    truncateData(data, ratio) {
        if (typeof data === 'string') {
            const targetLength = Math.floor(data.length * ratio);
            return data.substring(0, targetLength) + (targetLength < data.length ? '...[truncated]' : '');
        }
        if (Array.isArray(data)) {
            const targetLength = Math.floor(data.length * ratio);
            return data.slice(0, targetLength);
        }
        if (typeof data === 'object' && data !== null) {
            const result = {};
            const keys = Object.keys(data);
            const targetKeys = Math.floor(keys.length * ratio);
            for (let i = 0; i < Math.min(targetKeys, keys.length); i++) {
                const key = keys[i];
                if (key !== undefined) {
                    result[key] = this.truncateData(data[key], ratio);
                }
            }
            return result;
        }
        return data;
    }
    getOptimizationStats(context) {
        const metadata = context.metadata || {};
        const currentData = typeof context.data === 'object' ? JSON.stringify(context.data) : context.data;
        const currentSize = Buffer.from(currentData.toString()).length;
        return {
            isCompressed: metadata.compressed || false,
            originalSize: metadata.originalSize || currentSize,
            currentSize,
            compressionRatio: metadata.compressionRatio || 1.0,
            isOptimized: metadata.optimized || metadata.compressed || false
        };
    }
    async optimizeForPlatform(context, targetPlatform) {
        const platformOptions = {
            'synthetic': {
                compressionEnabled: true,
                platformFilter: 'synthetic',
                maxDataSize: 50 * 1024, // 50KB for flat-fee efficiency
                relevanceThreshold: 0.7
            },
            'openrouter': {
                compressionEnabled: false, // May interfere with premium model processing
                platformFilter: 'openrouter',
                maxDataSize: 200 * 1024, // 200KB for complex tasks
                relevanceThreshold: 0.3
            },
            'claude-code': {
                compressionEnabled: true,
                platformFilter: 'claude-code',
                maxDataSize: 100 * 1024, // 100KB balanced
                relevanceThreshold: 0.5
            }
        };
        const options = platformOptions[targetPlatform] || this.defaultOptions;
        console.log(`🎯 Optimizing context ${context.id} for platform: ${targetPlatform}`);
        return this.compress(context, options);
    }
}
//# sourceMappingURL=context-optimizer.js.map