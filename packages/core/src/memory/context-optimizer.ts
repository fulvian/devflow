/**
 * Context Optimizer - Compression and Platform-specific Filtering
 * Generated by Synthetic Code Agent: DEVFLOW-MEMORY-001
 * Optimizes context for memory usage and platform requirements
 */

import { UniversalContextFormat } from './universal-context-format';
import * as zlib from 'zlib';

export interface OptimizationOptions {
  compressionEnabled?: boolean;
  platformFilter?: string;
  maxDataSize?: number;
  relevanceThreshold?: number;
}

export class ContextOptimizer {
  private defaultOptions: OptimizationOptions = {
    compressionEnabled: true,
    maxDataSize: 100 * 1024, // 100KB max
    relevanceThreshold: 0.5
  };

  public compress(context: UniversalContextFormat, options?: OptimizationOptions): UniversalContextFormat {
    const opts = { ...this.defaultOptions, ...options };
    
    try {
      let optimizedData = context.data;
      
      // Apply platform-specific filtering
      if (opts.platformFilter) {
        optimizedData = this.filterForPlatform(optimizedData, opts.platformFilter);
      }
      
      // Apply size limits
      if (opts.maxDataSize) {
        optimizedData = this.limitDataSize(optimizedData, opts.maxDataSize);
      }
      
      // Apply compression
      if (opts.compressionEnabled) {
        const dataString = JSON.stringify(optimizedData);
        const compressedBuffer = zlib.gzipSync(dataString);
        
        const compressionRatio = compressedBuffer.length / Buffer.from(dataString).length;
        console.log(`ðŸ—œï¸  Compression ratio: ${(compressionRatio * 100).toFixed(1)}%`);
        
        return {
          ...context,
          data: compressedBuffer,
          metadata: {
            ...context.metadata,
            compressed: true,
            originalSize: Buffer.from(dataString).length,
            compressedSize: compressedBuffer.length,
            compressionRatio
          }
        };
      }
      
      return {
        ...context,
        data: optimizedData,
        metadata: {
          ...context.metadata,
          compressed: false,
          optimized: true
        }
      };
      
    } catch (error) {
      console.error('âŒ Compression failed:', error);
      return context; // Return original if compression fails
    }
  }

  public decompress(context: UniversalContextFormat): UniversalContextFormat {
    try {
      if (context.metadata?.compressed) {
        const decompressedBuffer = zlib.gunzipSync(context.data as Buffer);
        const decompressedData = JSON.parse(decompressedBuffer.toString());
        
        return {
          ...context,
          data: decompressedData,
          metadata: {
            ...context.metadata,
            compressed: false,
            decompressed: true
          }
        };
      }
      
      return context; // Return as-is if not compressed
      
    } catch (error) {
      console.error('âŒ Decompression failed:', error);
      throw new Error(`Failed to decompress context ${context.id}: ${error.message}`);
    }
  }

  private filterForPlatform(data: any, platform: string): any {
    // Platform-specific filtering logic
    const platformFilters: { [key: string]: (data: any) => any } = {
      'synthetic': (data) => {
        // Keep relevant data for Synthetic.new
        return this.filterByRelevance(data, ['code', 'implementation', 'functions']);
      },
      'openrouter': (data) => {
        // Keep complex reasoning data for OpenRouter
        return this.filterByRelevance(data, ['architecture', 'analysis', 'reasoning']);
      },
      'claude-code': (data) => {
        // Keep architectural and coordination data
        return this.filterByRelevance(data, ['architecture', 'coordination', 'decisions']);
      }
    };
    
    const filter = platformFilters[platform];
    return filter ? filter(data) : data;
  }

  private filterByRelevance(data: any, keywords: string[]): any {
    if (typeof data !== 'object' || data === null) {
      return data;
    }
    
    if (Array.isArray(data)) {
      return data.map(item => this.filterByRelevance(item, keywords));
    }
    
    const filtered: any = {};
    
    for (const [key, value] of Object.entries(data)) {
      const keyLower = key.toLowerCase();
      const isRelevant = keywords.some(keyword => 
        keyLower.includes(keyword.toLowerCase()) ||
        (typeof value === 'string' && value.toLowerCase().includes(keyword.toLowerCase()))
      );
      
      if (isRelevant) {
        filtered[key] = typeof value === 'object' ? this.filterByRelevance(value, keywords) : value;
      }
    }
    
    return Object.keys(filtered).length > 0 ? filtered : data; // Return original if nothing relevant found
  }

  private limitDataSize(data: any, maxSize: number): any {
    const dataString = JSON.stringify(data);
    const currentSize = Buffer.from(dataString).length;
    
    if (currentSize <= maxSize) {
      return data;
    }
    
    console.log(`âš ï¸  Data size ${currentSize} bytes exceeds limit ${maxSize} bytes, applying size reduction`);
    
    // Simple size reduction: truncate arrays and strings
    return this.truncateData(data, maxSize / currentSize);
  }

  private truncateData(data: any, ratio: number): any {
    if (typeof data === 'string') {
      const targetLength = Math.floor(data.length * ratio);
      return data.substring(0, targetLength) + (targetLength < data.length ? '...[truncated]' : '');
    }
    
    if (Array.isArray(data)) {
      const targetLength = Math.floor(data.length * ratio);
      return data.slice(0, targetLength);
    }
    
    if (typeof data === 'object' && data !== null) {
      const result: any = {};
      const keys = Object.keys(data);
      const targetKeys = Math.floor(keys.length * ratio);
      
      for (let i = 0; i < Math.min(targetKeys, keys.length); i++) {
        const key = keys[i];
        result[key] = this.truncateData(data[key], ratio);
      }
      
      return result;
    }
    
    return data;
  }

  public getOptimizationStats(context: UniversalContextFormat): {
    isCompressed: boolean;
    originalSize?: number;
    currentSize: number;
    compressionRatio?: number;
    isOptimized: boolean;
  } {
    const metadata = context.metadata || {};
    const currentData = typeof context.data === 'object' ? JSON.stringify(context.data) : context.data;
    const currentSize = Buffer.from(currentData.toString()).length;
    
    return {
      isCompressed: metadata.compressed || false,
      originalSize: metadata.originalSize,
      currentSize,
      compressionRatio: metadata.compressionRatio,
      isOptimized: metadata.optimized || metadata.compressed || false
    };
  }

  public async optimizeForPlatform(
    context: UniversalContextFormat, 
    targetPlatform: string
  ): Promise<UniversalContextFormat> {
    
    const platformOptions: { [key: string]: OptimizationOptions } = {
      'synthetic': {
        compressionEnabled: true,
        platformFilter: 'synthetic',
        maxDataSize: 50 * 1024, // 50KB for flat-fee efficiency
        relevanceThreshold: 0.7
      },
      'openrouter': {
        compressionEnabled: false, // May interfere with premium model processing
        platformFilter: 'openrouter',
        maxDataSize: 200 * 1024, // 200KB for complex tasks
        relevanceThreshold: 0.3
      },
      'claude-code': {
        compressionEnabled: true,
        platformFilter: 'claude-code',
        maxDataSize: 100 * 1024, // 100KB balanced
        relevanceThreshold: 0.5
      }
    };
    
    const options = platformOptions[targetPlatform] || this.defaultOptions;
    
    console.log(`ðŸŽ¯ Optimizing context ${context.id} for platform: ${targetPlatform}`);
    
    return this.compress(context, options);
  }
}