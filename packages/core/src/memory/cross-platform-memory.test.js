/**
 * Cross-Platform Memory System - Comprehensive Test Suite
 * Generated by Synthetic Code Agent: DEVFLOW-MEMORY-001
 * Tests for Phase 1 completion validation
 */
import { CrossPlatformSynchronizer } from './cross-platform-synchronizer.js';
import { ConflictResolver } from './conflict-resolver.js';
import { ContextOptimizer } from './context-optimizer.js';
import { SQLiteStorage } from './sqlite-storage.js';
// Test Suite
async function runCrossPlatformMemoryTests() {
    console.log('üß™ RUNNING CROSS-PLATFORM MEMORY SYSTEM TESTS');
    console.log('==============================================');
    let testsPassed = 0;
    let totalTests = 0;
    // Test 1: SQLite Storage
    console.log('\nüì¶ Testing SQLite Storage...');
    totalTests++;
    try {
        const storage = new SQLiteStorage(':memory:');
        const testContext = {
            id: 'test-1',
            data: { message: 'Hello DevFlow', code: 'function test() { return true; }' },
            lastUpdated: new Date(),
            version: 1,
            platform: 'synthetic',
            contextType: 'code',
            metadata: { tokens: 100, cost: 0.01, quality: 0.8 }
        };
        await storage.updateContext(testContext);
        const retrieved = await storage.getContextById('test-1');
        if (retrieved && retrieved.id === testContext.id && retrieved.platform === 'synthetic') {
            console.log('   ‚úÖ SQLite Storage: PASSED');
            testsPassed++;
        }
        else {
            console.log('   ‚ùå SQLite Storage: FAILED - Context mismatch');
        }
        storage.close();
    }
    catch (error) {
        console.log('   ‚ùå SQLite Storage: FAILED -', error instanceof Error ? error.message : String(error));
    }
    // Test 2: Context Optimizer
    console.log('\nüóúÔ∏è  Testing Context Optimizer...');
    totalTests++;
    try {
        const optimizer = new ContextOptimizer();
        const largeContext = {
            id: 'test-2',
            data: {
                largeText: 'x'.repeat(10000),
                codeSnippets: Array(100).fill({ code: 'function example() { return "test"; }' }),
                metadata: { description: 'Large test context for compression testing' }
            },
            lastUpdated: new Date(),
            version: 1
        };
        const compressed = optimizer.compress(largeContext);
        const _decompressed = optimizer.decompress(compressed);
        const stats = optimizer.getOptimizationStats(compressed);
        if (stats.isCompressed && stats.compressionRatio && stats.compressionRatio < 0.8) {
            console.log(`   ‚úÖ Context Optimizer: PASSED (${(stats.compressionRatio * 100).toFixed(1)}% compression)`);
            testsPassed++;
        }
        else {
            console.log('   ‚ùå Context Optimizer: FAILED - Insufficient compression');
        }
    }
    catch (error) {
        console.log('   ‚ùå Context Optimizer: FAILED -', error instanceof Error ? error.message : String(error));
    }
    // Test 3: Conflict Resolver
    console.log('\nüîÑ Testing Conflict Resolver...');
    totalTests++;
    try {
        const resolver = new ConflictResolver();
        const context1 = {
            id: 'test-3',
            data: { feature: 'login', status: 'in-progress', author: 'alice' },
            lastUpdated: new Date(Date.now() - 1000),
            version: 1
        };
        const context2 = {
            id: 'test-3',
            data: { feature: 'login', status: 'completed', reviewer: 'bob' },
            lastUpdated: new Date(),
            version: 2
        };
        const resolved = await resolver.resolve(context1, context2, 'merge');
        if (resolved.data.author === 'alice' && resolved.data.reviewer === 'bob' && resolved.data.status === 'completed') {
            console.log('   ‚úÖ Conflict Resolver: PASSED - Merge strategy worked');
            testsPassed++;
        }
        else {
            console.log('   ‚ùå Conflict Resolver: FAILED - Merge failed');
        }
    }
    catch (error) {
        console.log('   ‚ùå Conflict Resolver: FAILED -', error instanceof Error ? error.message : String(error));
    }
    // Test 4: Cross-Platform Synchronizer
    console.log('\n‚ö° Testing Cross-Platform Synchronizer...');
    totalTests++;
    try {
        const synchronizer = new CrossPlatformSynchronizer(':memory:');
        const context = {
            id: 'test-4',
            data: {
                task: 'Implement Phase 1 completion',
                platform: 'synthetic',
                status: 'completed'
            },
            lastUpdated: new Date(),
            version: 1,
            platform: 'synthetic',
            contextType: 'code'
        };
        const startTime = Date.now();
        await synchronizer.synchronize(context);
        const syncTime = Date.now() - startTime;
        const retrieved = await synchronizer.getContextById('test-4');
        const _syncStatus = synchronizer.getSyncStatus();
        if (retrieved && retrieved.id === context.id && syncTime < 200) {
            console.log(`   ‚úÖ Cross-Platform Synchronizer: PASSED (${syncTime}ms < 200ms target)`);
            testsPassed++;
        }
        else {
            console.log(`   ‚ùå Cross-Platform Synchronizer: FAILED - Sync time ${syncTime}ms or retrieval failed`);
        }
        synchronizer.close();
    }
    catch (error) {
        console.log('   ‚ùå Cross-Platform Synchronizer: FAILED -', error instanceof Error ? error.message : String(error));
    }
    // Test 5: Platform-specific Optimization
    console.log('\nüéØ Testing Platform-specific Optimization...');
    totalTests++;
    try {
        const optimizer = new ContextOptimizer();
        const context = {
            id: 'test-5',
            data: {
                code: 'function example() { return "synthetic"; }',
                architecture: 'microservices design pattern',
                reasoning: 'complex analysis of trade-offs',
                implementation: 'TypeScript with proper typing'
            },
            lastUpdated: new Date(),
            version: 1
        };
        const syntheticOptimized = await optimizer.optimizeForPlatform(context, 'synthetic');
        const openrouterOptimized = await optimizer.optimizeForPlatform(context, 'openrouter');
        // Synthetic should be compressed (flat fee efficiency)
        // OpenRouter should not be compressed (premium model processing)
        const syntheticStats = optimizer.getOptimizationStats(syntheticOptimized);
        const openrouterStats = optimizer.getOptimizationStats(openrouterOptimized);
        if (syntheticStats.isCompressed && !openrouterStats.isCompressed) {
            console.log('   ‚úÖ Platform-specific Optimization: PASSED');
            testsPassed++;
        }
        else {
            console.log('   ‚ùå Platform-specific Optimization: FAILED - Optimization rules not applied correctly');
        }
    }
    catch (error) {
        console.log('   ‚ùå Platform-specific Optimization: FAILED -', error instanceof Error ? error.message : String(error));
    }
    // Test 6: End-to-End Integration
    console.log('\nüöÄ Testing End-to-End Integration...');
    totalTests++;
    try {
        const synchronizer = new CrossPlatformSynchronizer(':memory:');
        // Simulate multi-platform workflow
        const contexts = [
            {
                id: 'workflow-1',
                data: { step: 'architecture', platform: 'claude-code', decision: 'microservices' },
                lastUpdated: new Date(Date.now() - 3000),
                version: 1,
                platform: 'claude-code',
                contextType: 'reasoning'
            },
            {
                id: 'workflow-2',
                data: { step: 'implementation', platform: 'synthetic', code: 'class Service {}' },
                lastUpdated: new Date(Date.now() - 2000),
                version: 1,
                platform: 'synthetic',
                contextType: 'code'
            },
            {
                id: 'workflow-3',
                data: { step: 'optimization', platform: 'openrouter', analysis: 'performance review' },
                lastUpdated: new Date(Date.now() - 1000),
                version: 1,
                platform: 'openrouter',
                contextType: 'reasoning'
            }
        ];
        // Synchronize all contexts
        for (const context of contexts) {
            await synchronizer.synchronize(context);
        }
        // Retrieve all contexts
        const allContexts = await synchronizer.getAllContexts();
        if (allContexts.length === 3 && allContexts.every(c => c.id.startsWith('workflow-'))) {
            console.log('   ‚úÖ End-to-End Integration: PASSED - Multi-platform workflow completed');
            testsPassed++;
        }
        else {
            console.log('   ‚ùå End-to-End Integration: FAILED - Context count or retrieval issue');
        }
        synchronizer.close();
    }
    catch (error) {
        console.log('   ‚ùå End-to-End Integration: FAILED -', error instanceof Error ? error.message : String(error));
    }
    // Test Results
    console.log('\nüìä TEST RESULTS');
    console.log('================');
    console.log(`Tests Passed: ${testsPassed}/${totalTests}`);
    console.log(`Success Rate: ${(testsPassed / totalTests * 100).toFixed(0)}%`);
    if (testsPassed === totalTests) {
        console.log('üéâ ALL TESTS PASSED - PHASE 1 CROSS-PLATFORM MEMORY SYSTEM READY!');
    }
    else {
        console.log('‚ö†Ô∏è  SOME TESTS FAILED - Review implementation before Phase 1 completion');
    }
    return testsPassed === totalTests;
}
// Export test runner
export { runCrossPlatformMemoryTests };
// Auto-run if executed directly
if (require.main === module) {
    runCrossPlatformMemoryTests();
}
//# sourceMappingURL=cross-platform-memory.test.js.map