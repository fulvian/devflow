/**
 * Cross-Platform Synchronizer - Real-time Context Updates
 * Generated by Synthetic Code Agent: DEVFLOW-MEMORY-001  
 * Implements <200ms synchronization target
 */

import { UniversalContextFormat, ContextSyncEvent, SyncStatus } from './universal-context-format';
import { ConflictResolver } from './conflict-resolver';
import { ContextOptimizer } from './context-optimizer';
import { SQLiteStorage } from './sqlite-storage';

export class CrossPlatformSynchronizer {
  private storage: SQLiteStorage;
  private conflictResolver: ConflictResolver;
  private contextOptimizer: ContextOptimizer;
  private eventQueue: ContextSyncEvent[] = [];
  private isProcessing = false;
  private syncInterval: NodeJS.Timeout | null = null;

  constructor(dbPath?: string) {
    this.storage = new SQLiteStorage(dbPath);
    this.conflictResolver = new ConflictResolver();
    this.contextOptimizer = new ContextOptimizer();
    
    // Start real-time sync processing
    this.startSyncProcessor();
  }

  private startSyncProcessor(): void {
    // Process sync events every 50ms for <200ms target
    this.syncInterval = setInterval(() => {
      this.processSyncQueue();
    }, 50);
  }

  public async synchronize(context: UniversalContextFormat): Promise<void> {
    const startTime = Date.now();
    
    try {
      const existingContext = await this.storage.getContextById(context.id);
      
      if (existingContext && existingContext.version > context.version) {
        // Conflict detected - use operational transforms
        const resolvedContext = await this.conflictResolver.resolve(existingContext, context);
        context = resolvedContext;
        
        // Emit conflict event
        this.addSyncEvent({
          type: 'conflict',
          contextId: context.id,
          timestamp: new Date(),
          source: context.platform || 'unknown',
          data: context
        });
      }

      // Optimize context before storage
      const optimizedContext = this.contextOptimizer.compress(context);
      await this.storage.updateContext(optimizedContext);
      
      // Emit update event
      this.addSyncEvent({
        type: existingContext ? 'update' : 'create',
        contextId: context.id,
        timestamp: new Date(),
        source: context.platform || 'unknown',
        data: context
      });

      const syncTime = Date.now() - startTime;
      console.log(`‚ö° Context sync completed in ${syncTime}ms (target: <200ms)`);
      
    } catch (error) {
      console.error('‚ùå Synchronization failed:', error);
      throw error;
    }
  }

  public async getContextById(id: string): Promise<UniversalContextFormat | null> {
    try {
      const context = await this.storage.getContextById(id);
      if (context) {
        return this.contextOptimizer.decompress(context);
      }
      return null;
    } catch (error) {
      console.error('‚ùå Failed to get context:', error);
      throw error;
    }
  }

  public async getAllContexts(): Promise<UniversalContextFormat[]> {
    try {
      const contexts = await this.storage.getAllContexts();
      return contexts.map(context => this.contextOptimizer.decompress(context));
    } catch (error) {
      console.error('‚ùå Failed to get all contexts:', error);
      throw error;
    }
  }

  public async deleteContext(id: string): Promise<void> {
    try {
      await this.storage.deleteContext(id);
      
      this.addSyncEvent({
        type: 'delete',
        contextId: id,
        timestamp: new Date(),
        source: 'system'
      });
      
    } catch (error) {
      console.error('‚ùå Failed to delete context:', error);
      throw error;
    }
  }

  public getSyncStatus(): SyncStatus {
    return {
      lastSync: new Date(), // TODO: track actual last sync time
      pendingUpdates: this.eventQueue.length,
      conflicts: this.eventQueue.filter(e => e.type === 'conflict').length,
      isOnline: true // TODO: implement network status detection
    };
  }

  private addSyncEvent(event: ContextSyncEvent): void {
    this.eventQueue.push(event);
    
    // Limit queue size to prevent memory issues
    if (this.eventQueue.length > 1000) {
      this.eventQueue = this.eventQueue.slice(-500); // Keep latest 500 events
    }
  }

  private async processSyncQueue(): Promise<void> {
    if (this.isProcessing || this.eventQueue.length === 0) {
      return;
    }

    this.isProcessing = true;
    
    try {
      // Process up to 10 events per cycle for performance
      const eventsToProcess = this.eventQueue.splice(0, 10);
      
      for (const event of eventsToProcess) {
        await this.processSyncEvent(event);
      }
      
    } catch (error) {
      console.error('‚ùå Error processing sync queue:', error);
    } finally {
      this.isProcessing = false;
    }
  }

  private async processSyncEvent(event: ContextSyncEvent): Promise<void> {
    // Placeholder for event processing logic
    // This would typically involve:
    // 1. Notifying other platform adapters
    // 2. Broadcasting to connected clients
    // 3. Updating caches
    // 4. Logging for analytics
    
    console.log(`üîÑ Processing sync event: ${event.type} for context ${event.contextId}`);
  }

  public close(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
    }
    this.storage.close();
  }
}