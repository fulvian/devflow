/**
 * SQLite Storage for Cross-Platform Memory System
 * Generated by Synthetic Code Agent: DEVFLOW-MEMORY-001
 * WAL mode enabled for concurrent access
 */
import Database from 'sqlite3';
import * as path from 'path';
export class SQLiteStorage {
    db;
    dbPath;
    constructor(dbPath) {
        this.dbPath = dbPath || path.join(process.cwd(), 'data', 'devflow-memory.db');
        this.db = new Database.Database(this.dbPath);
        this.initialize();
    }
    initialize() {
        this.db.serialize(() => {
            // Enable WAL mode for better concurrent access
            this.db.run('PRAGMA journal_mode=WAL');
            this.db.run('PRAGMA synchronous=NORMAL');
            this.db.run('PRAGMA cache_size=10000');
            this.db.run('PRAGMA temp_store=memory');
            // Create contexts table with enhanced schema
            this.db.run(`
        CREATE TABLE IF NOT EXISTS contexts (
          id TEXT PRIMARY KEY,
          data BLOB NOT NULL,
          lastUpdated DATETIME NOT NULL,
          version INTEGER NOT NULL DEFAULT 1,
          platform TEXT,
          contextType TEXT,
          metadata TEXT,
          created DATETIME DEFAULT CURRENT_TIMESTAMP,
          tokensUsed INTEGER DEFAULT 0,
          costUsd REAL DEFAULT 0.0,
          qualityScore REAL DEFAULT 0.0
        )
      `);
            // Create indexes for performance
            this.db.run('CREATE INDEX IF NOT EXISTS idx_contexts_lastUpdated ON contexts(lastUpdated)');
            this.db.run('CREATE INDEX IF NOT EXISTS idx_contexts_platform ON contexts(platform)');
            this.db.run('CREATE INDEX IF NOT EXISTS idx_contexts_contextType ON contexts(contextType)');
            this.db.run('CREATE INDEX IF NOT EXISTS idx_contexts_version ON contexts(version)');
            // Create sync events table for audit trail
            this.db.run(`
        CREATE TABLE IF NOT EXISTS sync_events (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          contextId TEXT NOT NULL,
          eventType TEXT NOT NULL,
          timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
          source TEXT,
          data TEXT,
          FOREIGN KEY (contextId) REFERENCES contexts (id)
        )
      `);
            this.db.run('CREATE INDEX IF NOT EXISTS idx_sync_events_contextId ON sync_events(contextId)');
            this.db.run('CREATE INDEX IF NOT EXISTS idx_sync_events_timestamp ON sync_events(timestamp)');
        });
    }
    async getContextById(id) {
        return new Promise((resolve, reject) => {
            this.db.get('SELECT * FROM contexts WHERE id = ?', [id], (err, row) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(row ? this.rowToContext(row) : null);
                }
            });
        });
    }
    async getAllContexts() {
        return new Promise((resolve, reject) => {
            this.db.all('SELECT * FROM contexts ORDER BY lastUpdated DESC', [], (err, rows) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(rows.map(row => this.rowToContext(row)));
                }
            });
        });
    }
    async getContextsByPlatform(platform) {
        return new Promise((resolve, reject) => {
            this.db.all('SELECT * FROM contexts WHERE platform = ? ORDER BY lastUpdated DESC', [platform], (err, rows) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(rows.map(row => this.rowToContext(row)));
                }
            });
        });
    }
    async getContextsByType(contextType) {
        return new Promise((resolve, reject) => {
            this.db.all('SELECT * FROM contexts WHERE contextType = ? ORDER BY lastUpdated DESC', [contextType], (err, rows) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(rows.map(row => this.rowToContext(row)));
                }
            });
        });
    }
    async updateContext(context) {
        return new Promise((resolve, reject) => {
            const stmt = this.db.prepare(`
        INSERT OR REPLACE INTO contexts 
        (id, data, lastUpdated, version, platform, contextType, metadata, tokensUsed, costUsd, qualityScore) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);
            stmt.run([
                context.id,
                context.data,
                context.lastUpdated.toISOString(),
                context.version,
                context.platform || null,
                context.contextType || null,
                JSON.stringify(context.metadata || {}),
                context.metadata?.tokens || 0,
                context.metadata?.cost || 0.0,
                context.metadata?.quality || 0.0
            ], function (err) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
            stmt.finalize();
        });
    }
    async deleteContext(id) {
        return new Promise((resolve, reject) => {
            this.db.run('DELETE FROM contexts WHERE id = ?', [id], function (err) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    async logSyncEvent(contextId, eventType, source, data) {
        return new Promise((resolve, reject) => {
            this.db.run('INSERT INTO sync_events (contextId, eventType, source, data) VALUES (?, ?, ?, ?)', [contextId, eventType, source, data ? JSON.stringify(data) : null], function (err) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    async getStorageStats() {
        return new Promise((resolve, reject) => {
            const stats = {
                totalContexts: 0,
                totalSize: 0,
                contextsByPlatform: {},
                contextsByType: {},
                avgCost: 0,
                avgQuality: 0
            };
            this.db.serialize(() => {
                // Get total contexts and averages
                this.db.get(`
          SELECT 
            COUNT(*) as total,
            AVG(costUsd) as avgCost,
            AVG(qualityScore) as avgQuality
          FROM contexts
        `, [], (err, row) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    stats.totalContexts = row.total;
                    stats.avgCost = row.avgCost || 0;
                    stats.avgQuality = row.avgQuality || 0;
                });
                // Get contexts by platform
                this.db.all(`
          SELECT platform, COUNT(*) as count 
          FROM contexts 
          WHERE platform IS NOT NULL 
          GROUP BY platform
        `, [], (err, rows) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    rows.forEach((row) => {
                        stats.contextsByPlatform[row.platform] = row.count;
                    });
                });
                // Get contexts by type
                this.db.all(`
          SELECT contextType, COUNT(*) as count 
          FROM contexts 
          WHERE contextType IS NOT NULL 
          GROUP BY contextType
        `, [], (err, rows) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    rows.forEach((row) => {
                        stats.contextsByType[row.contextType] = row.count;
                    });
                    resolve(stats);
                });
            });
        });
    }
    async cleanup(olderThanDays = 30) {
        return new Promise((resolve, reject) => {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
            this.db.run('DELETE FROM contexts WHERE lastUpdated < ?', [cutoffDate.toISOString()], function (err) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(this.changes || 0);
                }
            });
        });
    }
    rowToContext(row) {
        return {
            id: row.id,
            data: row.data,
            lastUpdated: new Date(row.lastUpdated),
            version: row.version,
            platform: row.platform,
            contextType: row.contextType,
            metadata: row.metadata ? JSON.parse(row.metadata) : undefined
        };
    }
    close() {
        this.db.close((err) => {
            if (err) {
                console.error('Error closing database:', err);
            }
            else {
                console.log('ðŸ“¦ SQLite database connection closed');
            }
        });
    }
    async vacuum() {
        return new Promise((resolve, reject) => {
            this.db.run('VACUUM', (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    console.log('ðŸ§¹ Database vacuumed successfully');
                    resolve();
                }
            });
        });
    }
}
//# sourceMappingURL=sqlite-storage.js.map