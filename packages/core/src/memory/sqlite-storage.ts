/**
 * SQLite Storage for Cross-Platform Memory System
 * Generated by Synthetic Code Agent: DEVFLOW-MEMORY-001
 * WAL mode enabled for concurrent access
 */

import { UniversalContextFormat } from './universal-context-format';
import Database from 'sqlite3';
import * as path from 'path';

export class SQLiteStorage {
  private db: Database.Database;
  private dbPath: string;

  constructor(dbPath?: string) {
    this.dbPath = dbPath || path.join(process.cwd(), 'data', 'devflow-memory.db');
    this.db = new Database.Database(this.dbPath);
    this.initialize();
  }

  private initialize(): void {
    this.db.serialize(() => {
      // Enable WAL mode for better concurrent access
      this.db.run('PRAGMA journal_mode=WAL');
      this.db.run('PRAGMA synchronous=NORMAL');
      this.db.run('PRAGMA cache_size=10000');
      this.db.run('PRAGMA temp_store=memory');

      // Create contexts table with enhanced schema
      this.db.run(`
        CREATE TABLE IF NOT EXISTS contexts (
          id TEXT PRIMARY KEY,
          data BLOB NOT NULL,
          lastUpdated DATETIME NOT NULL,
          version INTEGER NOT NULL DEFAULT 1,
          platform TEXT,
          contextType TEXT,
          metadata TEXT,
          created DATETIME DEFAULT CURRENT_TIMESTAMP,
          tokensUsed INTEGER DEFAULT 0,
          costUsd REAL DEFAULT 0.0,
          qualityScore REAL DEFAULT 0.0
        )
      `);

      // Create indexes for performance
      this.db.run('CREATE INDEX IF NOT EXISTS idx_contexts_lastUpdated ON contexts(lastUpdated)');
      this.db.run('CREATE INDEX IF NOT EXISTS idx_contexts_platform ON contexts(platform)');
      this.db.run('CREATE INDEX IF NOT EXISTS idx_contexts_contextType ON contexts(contextType)');
      this.db.run('CREATE INDEX IF NOT EXISTS idx_contexts_version ON contexts(version)');

      // Create sync events table for audit trail
      this.db.run(`
        CREATE TABLE IF NOT EXISTS sync_events (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          contextId TEXT NOT NULL,
          eventType TEXT NOT NULL,
          timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
          source TEXT,
          data TEXT,
          FOREIGN KEY (contextId) REFERENCES contexts (id)
        )
      `);

      this.db.run('CREATE INDEX IF NOT EXISTS idx_sync_events_contextId ON sync_events(contextId)');
      this.db.run('CREATE INDEX IF NOT EXISTS idx_sync_events_timestamp ON sync_events(timestamp)');
    });
  }

  public async getContextById(id: string): Promise<UniversalContextFormat | null> {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT * FROM contexts WHERE id = ?',
        [id],
        (err, row) => {
          if (err) {
            reject(err);
          } else {
            resolve(row ? this.rowToContext(row) : null);
          }
        }
      );
    });
  }

  public async getAllContexts(): Promise<UniversalContextFormat[]> {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM contexts ORDER BY lastUpdated DESC',
        [],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows.map(row => this.rowToContext(row)));
          }
        }
      );
    });
  }

  public async getContextsByPlatform(platform: string): Promise<UniversalContextFormat[]> {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM contexts WHERE platform = ? ORDER BY lastUpdated DESC',
        [platform],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows.map(row => this.rowToContext(row)));
          }
        }
      );
    });
  }

  public async getContextsByType(contextType: string): Promise<UniversalContextFormat[]> {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM contexts WHERE contextType = ? ORDER BY lastUpdated DESC',
        [contextType],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows.map(row => this.rowToContext(row)));
          }
        }
      );
    });
  }

  public async updateContext(context: UniversalContextFormat): Promise<void> {
    return new Promise((resolve, reject) => {
      const stmt = this.db.prepare(`
        INSERT OR REPLACE INTO contexts 
        (id, data, lastUpdated, version, platform, contextType, metadata, tokensUsed, costUsd, qualityScore) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

      stmt.run([
        context.id,
        context.data,
        context.lastUpdated.toISOString(),
        context.version,
        context.platform || null,
        context.contextType || null,
        JSON.stringify(context.metadata || {}),
        context.metadata?.tokens || 0,
        context.metadata?.cost || 0.0,
        context.metadata?.quality || 0.0
      ], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });

      stmt.finalize();
    });
  }

  public async deleteContext(id: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.run(
        'DELETE FROM contexts WHERE id = ?',
        [id],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });
  }

  public async logSyncEvent(contextId: string, eventType: string, source: string, data?: any): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.run(
        'INSERT INTO sync_events (contextId, eventType, source, data) VALUES (?, ?, ?, ?)',
        [contextId, eventType, source, data ? JSON.stringify(data) : null],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });
  }

  public async getStorageStats(): Promise<{
    totalContexts: number;
    totalSize: number;
    contextsByPlatform: { [platform: string]: number };
    contextsByType: { [type: string]: number };
    avgCost: number;
    avgQuality: number;
  }> {
    return new Promise((resolve, reject) => {
      const stats = {
        totalContexts: 0,
        totalSize: 0,
        contextsByPlatform: {} as { [platform: string]: number },
        contextsByType: {} as { [type: string]: number },
        avgCost: 0,
        avgQuality: 0
      };

      this.db.serialize(() => {
        // Get total contexts and averages
        this.db.get(`
          SELECT 
            COUNT(*) as total,
            AVG(costUsd) as avgCost,
            AVG(qualityScore) as avgQuality
          FROM contexts
        `, [], (err, row) => {
          if (err) {
            reject(err);
            return;
          }
          stats.totalContexts = row.total;
          stats.avgCost = row.avgCost || 0;
          stats.avgQuality = row.avgQuality || 0;
        });

        // Get contexts by platform
        this.db.all(`
          SELECT platform, COUNT(*) as count 
          FROM contexts 
          WHERE platform IS NOT NULL 
          GROUP BY platform
        `, [], (err, rows) => {
          if (err) {
            reject(err);
            return;
          }
          rows.forEach((row: any) => {
            stats.contextsByPlatform[row.platform] = row.count;
          });
        });

        // Get contexts by type
        this.db.all(`
          SELECT contextType, COUNT(*) as count 
          FROM contexts 
          WHERE contextType IS NOT NULL 
          GROUP BY contextType
        `, [], (err, rows) => {
          if (err) {
            reject(err);
            return;
          }
          rows.forEach((row: any) => {
            stats.contextsByType[row.contextType] = row.count;
          });

          resolve(stats);
        });
      });
    });
  }

  public async cleanup(olderThanDays: number = 30): Promise<number> {
    return new Promise((resolve, reject) => {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);

      this.db.run(
        'DELETE FROM contexts WHERE lastUpdated < ?',
        [cutoffDate.toISOString()],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve(this.changes || 0);
          }
        }
      );
    });
  }

  private rowToContext(row: any): UniversalContextFormat {
    return {
      id: row.id,
      data: row.data,
      lastUpdated: new Date(row.lastUpdated),
      version: row.version,
      platform: row.platform,
      contextType: row.contextType,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    };
  }

  public close(): void {
    this.db.close((err) => {
      if (err) {
        console.error('Error closing database:', err);
      } else {
        console.log('ðŸ“¦ SQLite database connection closed');
      }
    });
  }

  public async vacuum(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.run('VACUUM', (err) => {
        if (err) {
          reject(err);
        } else {
          console.log('ðŸ§¹ Database vacuumed successfully');
          resolve();
        }
      });
    });
  }
}