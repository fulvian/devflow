/**
 * Advanced Task Router - ML-Powered Intelligent Routing
 * Generated by Synthetic Code Agent: DEVFLOW-ROUTER-001
 * Qwen 2.5 Coder 32B - 1,867 tokens processed
 */
import Database from 'sqlite3';
import { v4 as uuidv4 } from 'uuid';
// TaskClassification Implementation
export class SimpleTaskClassifier {
    codeKeywords = ['code', 'function', 'implement', 'write', 'create', 'build', 'develop', 'typescript', 'javascript', 'python'];
    reasoningKeywords = ['analyze', 'reasoning', 'explain', 'architecture', 'design', 'strategy', 'decision', 'compare', 'evaluate'];
    contextKeywords = ['context', 'documentation', 'analyze codebase', 'understand', 'review', 'large', 'comprehensive'];
    classify(taskDescription) {
        const description = taskDescription.toLowerCase();
        const codeScore = this.calculateScore(description, this.codeKeywords);
        const reasoningScore = this.calculateScore(description, this.reasoningKeywords);
        const contextScore = this.calculateScore(description, this.contextKeywords);
        // Determine best match
        if (codeScore > reasoningScore && codeScore > contextScore) {
            return { type: 'code', confidence: Math.min(0.9, 0.6 + codeScore * 0.3) };
        }
        else if (reasoningScore > contextScore) {
            return { type: 'reasoning', confidence: Math.min(0.9, 0.6 + reasoningScore * 0.3) };
        }
        else if (contextScore > 0.3) {
            return { type: 'context', confidence: Math.min(0.9, 0.6 + contextScore * 0.3) };
        }
        else {
            return { type: 'mixed', confidence: 0.6 };
        }
    }
    calculateScore(description, keywords) {
        let score = 0;
        keywords.forEach(keyword => {
            if (description.includes(keyword)) {
                score += 1;
            }
        });
        return Math.min(1.0, score / keywords.length);
    }
}
// PlatformSpecializationMatrix Implementation
export class PlatformSpecializationMatrix {
    matrix = {
        code: {
            platform: 'Synthetic.new',
            agent: 'code',
            confidence: 0.9,
            costEfficiency: 0.95 // High due to flat fee
        },
        reasoning: {
            platform: 'Synthetic.new',
            agent: 'reasoning',
            confidence: 0.85,
            costEfficiency: 0.90
        },
        context: {
            platform: 'Synthetic.new',
            agent: 'context',
            confidence: 0.80,
            costEfficiency: 0.85
        },
        mixed: {
            platform: 'OpenRouter',
            agent: 'premium',
            confidence: 0.75,
            costEfficiency: 0.60 // Lower due to pay-per-use
        }
    };
    getPlatformForTask(taskType, constraints = {}, userPreferences = {}) {
        const baseDecision = this.matrix[taskType] || this.matrix['mixed'];
        // Apply budget constraints
        if (constraints.budgetLimit && constraints.budgetLimit < 1.0) {
            // Force to Synthetic.new for low budget
            if (taskType !== 'mixed') {
                return {
                    platform: 'Synthetic.new',
                    agent: this.getSyntheticAgentForTask(taskType),
                    confidence: (baseDecision?.confidence || 0.5) * 0.9
                };
            }
        }
        // Apply user preferences
        if (userPreferences.preferCostEfficiency) {
            return {
                platform: 'Synthetic.new',
                agent: this.getSyntheticAgentForTask(taskType),
                confidence: (baseDecision?.confidence || 0.5) * 0.95
            };
        }
        return {
            platform: baseDecision?.platform || 'synthetic',
            agent: baseDecision?.agent || 'default',
            confidence: baseDecision?.confidence || 0.5
        };
    }
    getSyntheticAgentForTask(taskType) {
        const agentMap = {
            code: 'code',
            reasoning: 'reasoning',
            context: 'context',
            mixed: 'auto'
        };
        return agentMap[taskType] || 'auto';
    }
}
// PerformanceLearning Implementation
export class PerformanceLearning {
    db;
    // private _dbPath: string;
    constructor(dbPath = ':memory:') {
        // this._dbPath = dbPath;
        this.db = new Database.Database(dbPath);
        this.initializeDatabase();
    }
    initializeDatabase() {
        this.db.serialize(() => {
            this.db.run(`CREATE TABLE IF NOT EXISTS routing_outcomes (
                taskId TEXT PRIMARY KEY,
                taskType TEXT,
                platform TEXT,
                agent TEXT,
                outcome TEXT,
                executionTime INTEGER,
                qualityScore REAL,
                costUsd REAL,
                timestamp INTEGER
            )`);
            this.db.run(`CREATE TABLE IF NOT EXISTS routing_performance (
                taskType TEXT,
                platform TEXT,
                agent TEXT,
                avgQualityScore REAL,
                avgExecutionTime INTEGER,
                avgCostUsd REAL,
                successRate REAL,
                sampleCount INTEGER,
                lastUpdated INTEGER,
                PRIMARY KEY (taskType, platform, agent)
            )`);
        });
    }
    trackOutcome(taskId, outcome) {
        const stmt = this.db.prepare(`INSERT OR REPLACE INTO routing_outcomes 
            (taskId, taskType, platform, agent, outcome, executionTime, qualityScore, costUsd, timestamp) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`);
        stmt.run(taskId, outcome.taskType || 'unknown', outcome.platform || 'unknown', outcome.agent || 'unknown', JSON.stringify(outcome), outcome.executionTime || 0, outcome.qualityScore || 0.5, outcome.costUsd || 0.0, Date.now());
        stmt.finalize();
        // Update performance metrics
        this.updatePerformanceMetrics(outcome.taskType, outcome.platform, outcome.agent);
    }
    updatePerformanceMetrics(taskType, platform, agent) {
        this.db.serialize(() => {
            // Calculate aggregate metrics
            this.db.run(`INSERT OR REPLACE INTO routing_performance 
                (taskType, platform, agent, avgQualityScore, avgExecutionTime, avgCostUsd, successRate, sampleCount, lastUpdated)
                SELECT 
                    taskType, platform, agent,
                    AVG(qualityScore) as avgQualityScore,
                    AVG(executionTime) as avgExecutionTime,
                    AVG(costUsd) as avgCostUsd,
                    AVG(CASE WHEN qualityScore > 0.7 THEN 1.0 ELSE 0.0 END) as successRate,
                    COUNT(*) as sampleCount,
                    ? as lastUpdated
                FROM routing_outcomes 
                WHERE taskType = ? AND platform = ? AND agent = ?
                GROUP BY taskType, platform, agent`, [Date.now(), taskType, platform, agent]);
        });
    }
    adaptRouting() {
        // Simple adaptation: log current performance metrics
        console.log("🔄 Adapting routing based on historical performance...");
        this.db.all(`SELECT taskType, platform, agent, avgQualityScore, successRate, sampleCount 
                    FROM routing_performance 
                    WHERE sampleCount >= 3 
                    ORDER BY avgQualityScore DESC`, [], (err, rows) => {
            if (err) {
                console.error("Error retrieving performance metrics:", err);
                return;
            }
            console.log("📊 Current Performance Metrics:");
            rows.forEach((row) => {
                console.log(`  ${row.taskType}/${row.platform}/${row.agent}: Quality ${row.avgQualityScore.toFixed(2)}, Success ${(row.successRate * 100).toFixed(0)}% (${row.sampleCount} samples)`);
            });
        });
    }
    close() {
        this.db.close();
    }
}
// Main TaskRouter Implementation
export class AdvancedTaskRouter {
    taskClassifier;
    platformMatrix;
    performanceLearning;
    coordinator;
    constructor(coordinator, dbPath) {
        this.taskClassifier = new SimpleTaskClassifier();
        this.platformMatrix = new PlatformSpecializationMatrix();
        this.performanceLearning = new PerformanceLearning(dbPath);
        this.coordinator = coordinator;
    }
    async route(taskDescription, constraints = {}, userPreferences = {}) {
        const startTime = Date.now();
        try {
            // Step 1: Classify the task
            const classification = this.taskClassifier.classify(taskDescription);
            // Step 2: Get platform recommendation
            const routingDecision = this.platformMatrix.getPlatformForTask(classification.type, constraints, userPreferences);
            // Step 3: Generate unique task ID
            const taskId = uuidv4();
            const decision = {
                taskId,
                platform: routingDecision.platform,
                agent: routingDecision.agent,
                confidence: routingDecision.confidence,
                classification
            };
            // Step 4: Execute task if coordinator available
            if (this.coordinator) {
                const result = await this.coordinator.sendTaskToPlatform(taskId, routingDecision.platform, routingDecision.agent);
                // Step 5: Track outcome for learning
                const executionTime = Date.now() - startTime;
                this.performanceLearning.trackOutcome(taskId, {
                    taskType: classification.type,
                    platform: routingDecision.platform,
                    agent: routingDecision.agent,
                    result: result,
                    executionTime: executionTime,
                    qualityScore: this.estimateQualityScore(result),
                    costUsd: this.estimateCost(routingDecision.platform, classification.type)
                });
                // Periodic adaptation
                if (Math.random() < 0.1) { // 10% chance
                    this.performanceLearning.adaptRouting();
                }
            }
            console.log(`🎯 Task routed: ${classification.type} → ${routingDecision.platform}/${routingDecision.agent} (${(routingDecision.confidence * 100).toFixed(0)}% confidence)`);
            return decision;
        }
        catch (error) {
            console.error("❌ Error routing task:", error);
            // Fallback decision
            return {
                taskId: uuidv4(),
                platform: 'Synthetic.new',
                agent: 'auto',
                confidence: 0.5,
                classification: { type: 'mixed', confidence: 0.5 }
            };
        }
    }
    estimateQualityScore(result) {
        // Simple heuristic for quality scoring
        if (!result)
            return 0.3;
        if (result.status === 'completed')
            return 0.8;
        if (result.status === 'success')
            return 0.9;
        return 0.5;
    }
    estimateCost(platform, taskType) {
        // Cost estimation based on platform and task type
        if (platform === 'Synthetic.new') {
            return 0.0; // Flat fee model
        }
        else if (platform === 'OpenRouter') {
            const baseCost = 0.02; // Base cost per task
            const complexityMultiplier = taskType === 'mixed' ? 2.0 : 1.0;
            return baseCost * complexityMultiplier;
        }
        return 0.01; // Default estimate
    }
    getPerformanceMetrics() {
        return this.performanceLearning;
    }
    close() {
        this.performanceLearning.close();
    }
}
//# sourceMappingURL=advanced-task-router.js.map