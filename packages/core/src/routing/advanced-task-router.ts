/**
 * Advanced Task Router - ML-Powered Intelligent Routing
 * Generated by Synthetic Code Agent: DEVFLOW-ROUTER-001
 * Qwen 2.5 Coder 32B - 1,867 tokens processed
 */

import Database from 'sqlite3';
import { v4 as uuidv4 } from 'uuid';

// Core Interfaces
export interface TaskClassification {
    classify(taskDescription: string): { type: string, confidence: number };
}

export interface PlatformSpecializationMatrix {
    getPlatformForTask(taskType: string, constraints: any, userPreferences: any): { platform: string, agent: string, confidence: number };
}

export interface PerformanceLearning {
    trackOutcome(taskId: string, outcome: any): void;
    adaptRouting(): void;
}

export interface MultiPlatformCoordinator {
    sendTaskToPlatform(taskId: string, platform: string, agent: string): Promise<any>;
}

export interface TaskRoutingDecision {
    platform: string;
    agent: string;
    confidence: number;
    taskId: string;
    classification: { type: string, confidence: number };
}

// TaskClassification Implementation
export class SimpleTaskClassifier implements TaskClassification {
    private codeKeywords = ['code', 'function', 'implement', 'write', 'create', 'build', 'develop', 'typescript', 'javascript', 'python'];
    private reasoningKeywords = ['analyze', 'reasoning', 'explain', 'architecture', 'design', 'strategy', 'decision', 'compare', 'evaluate'];
    private contextKeywords = ['context', 'documentation', 'analyze codebase', 'understand', 'review', 'large', 'comprehensive'];

    classify(taskDescription: string): { type: string, confidence: number } {
        const description = taskDescription.toLowerCase();
        
        const codeScore = this.calculateScore(description, this.codeKeywords);
        const reasoningScore = this.calculateScore(description, this.reasoningKeywords);
        const contextScore = this.calculateScore(description, this.contextKeywords);

        // Determine best match
        if (codeScore > reasoningScore && codeScore > contextScore) {
            return { type: 'code', confidence: Math.min(0.9, 0.6 + codeScore * 0.3) };
        } else if (reasoningScore > contextScore) {
            return { type: 'reasoning', confidence: Math.min(0.9, 0.6 + reasoningScore * 0.3) };
        } else if (contextScore > 0.3) {
            return { type: 'context', confidence: Math.min(0.9, 0.6 + contextScore * 0.3) };
        } else {
            return { type: 'mixed', confidence: 0.6 };
        }
    }

    private calculateScore(description: string, keywords: string[]): number {
        let score = 0;
        keywords.forEach(keyword => {
            if (description.includes(keyword)) {
                score += 1;
            }
        });
        return Math.min(1.0, score / keywords.length);
    }
}

// PlatformSpecializationMatrix Implementation
export class PlatformSpecializationMatrix implements PlatformSpecializationMatrix {
    private matrix: { [key: string]: { platform: string, agent: string, confidence: number, costEfficiency: number } } = {
        code: { 
            platform: 'Synthetic.new', 
            agent: 'code', 
            confidence: 0.9,
            costEfficiency: 0.95  // High due to flat fee
        },
        reasoning: { 
            platform: 'Synthetic.new', 
            agent: 'reasoning', 
            confidence: 0.85,
            costEfficiency: 0.90
        },
        context: { 
            platform: 'Synthetic.new', 
            agent: 'context', 
            confidence: 0.80,
            costEfficiency: 0.85
        },
        mixed: { 
            platform: 'OpenRouter', 
            agent: 'premium', 
            confidence: 0.75,
            costEfficiency: 0.60  // Lower due to pay-per-use
        }
    };

    getPlatformForTask(taskType: string, constraints: any = {}, userPreferences: any = {}): { platform: string, agent: string, confidence: number } {
        const baseDecision = this.matrix[taskType] || this.matrix['mixed'];
        
        // Apply budget constraints
        if (constraints.budgetLimit && constraints.budgetLimit < 1.0) {
            // Force to Synthetic.new for low budget
            if (taskType !== 'mixed') {
                return {
                    platform: 'Synthetic.new',
                    agent: this.getSyntheticAgentForTask(taskType),
                    confidence: baseDecision.confidence * 0.9
                };
            }
        }

        // Apply user preferences
        if (userPreferences.preferCostEfficiency) {
            return {
                platform: 'Synthetic.new',
                agent: this.getSyntheticAgentForTask(taskType),
                confidence: baseDecision.confidence * 0.95
            };
        }

        return {
            platform: baseDecision.platform,
            agent: baseDecision.agent,
            confidence: baseDecision.confidence
        };
    }

    private getSyntheticAgentForTask(taskType: string): string {
        const agentMap: { [key: string]: string } = {
            code: 'code',
            reasoning: 'reasoning',
            context: 'context',
            mixed: 'auto'
        };
        return agentMap[taskType] || 'auto';
    }
}

// PerformanceLearning Implementation
export class PerformanceLearning implements PerformanceLearning {
    private db: Database.Database;
    private dbPath: string;

    constructor(dbPath: string = ':memory:') {
        this.dbPath = dbPath;
        this.db = new Database.Database(dbPath);
        this.initializeDatabase();
    }

    private initializeDatabase(): void {
        this.db.serialize(() => {
            this.db.run(`CREATE TABLE IF NOT EXISTS routing_outcomes (
                taskId TEXT PRIMARY KEY,
                taskType TEXT,
                platform TEXT,
                agent TEXT,
                outcome TEXT,
                executionTime INTEGER,
                qualityScore REAL,
                costUsd REAL,
                timestamp INTEGER
            )`);

            this.db.run(`CREATE TABLE IF NOT EXISTS routing_performance (
                taskType TEXT,
                platform TEXT,
                agent TEXT,
                avgQualityScore REAL,
                avgExecutionTime INTEGER,
                avgCostUsd REAL,
                successRate REAL,
                sampleCount INTEGER,
                lastUpdated INTEGER,
                PRIMARY KEY (taskType, platform, agent)
            )`);
        });
    }

    trackOutcome(taskId: string, outcome: any): void {
        const stmt = this.db.prepare(`INSERT OR REPLACE INTO routing_outcomes 
            (taskId, taskType, platform, agent, outcome, executionTime, qualityScore, costUsd, timestamp) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`);
        
        stmt.run(
            taskId,
            outcome.taskType || 'unknown',
            outcome.platform || 'unknown',
            outcome.agent || 'unknown',
            JSON.stringify(outcome),
            outcome.executionTime || 0,
            outcome.qualityScore || 0.5,
            outcome.costUsd || 0.0,
            Date.now()
        );
        stmt.finalize();

        // Update performance metrics
        this.updatePerformanceMetrics(outcome.taskType, outcome.platform, outcome.agent);
    }

    private updatePerformanceMetrics(taskType: string, platform: string, agent: string): void {
        this.db.serialize(() => {
            // Calculate aggregate metrics
            this.db.run(`INSERT OR REPLACE INTO routing_performance 
                (taskType, platform, agent, avgQualityScore, avgExecutionTime, avgCostUsd, successRate, sampleCount, lastUpdated)
                SELECT 
                    taskType, platform, agent,
                    AVG(qualityScore) as avgQualityScore,
                    AVG(executionTime) as avgExecutionTime,
                    AVG(costUsd) as avgCostUsd,
                    AVG(CASE WHEN qualityScore > 0.7 THEN 1.0 ELSE 0.0 END) as successRate,
                    COUNT(*) as sampleCount,
                    ? as lastUpdated
                FROM routing_outcomes 
                WHERE taskType = ? AND platform = ? AND agent = ?
                GROUP BY taskType, platform, agent`,
                [Date.now(), taskType, platform, agent]
            );
        });
    }

    adaptRouting(): void {
        // Simple adaptation: log current performance metrics
        console.log("🔄 Adapting routing based on historical performance...");
        
        this.db.all(`SELECT taskType, platform, agent, avgQualityScore, successRate, sampleCount 
                    FROM routing_performance 
                    WHERE sampleCount >= 3 
                    ORDER BY avgQualityScore DESC`, [], (err, rows) => {
            if (err) {
                console.error("Error retrieving performance metrics:", err);
                return;
            }
            
            console.log("📊 Current Performance Metrics:");
            rows.forEach((row: any) => {
                console.log(`  ${row.taskType}/${row.platform}/${row.agent}: Quality ${row.avgQualityScore.toFixed(2)}, Success ${(row.successRate * 100).toFixed(0)}% (${row.sampleCount} samples)`);
            });
        });
    }

    close(): void {
        this.db.close();
    }
}

// Main TaskRouter Implementation
export class AdvancedTaskRouter {
    private taskClassifier: TaskClassification;
    private platformMatrix: PlatformSpecializationMatrix;
    private performanceLearning: PerformanceLearning;
    private coordinator?: MultiPlatformCoordinator;

    constructor(coordinator?: MultiPlatformCoordinator, dbPath?: string) {
        this.taskClassifier = new SimpleTaskClassifier();
        this.platformMatrix = new PlatformSpecializationMatrix();
        this.performanceLearning = new PerformanceLearning(dbPath);
        this.coordinator = coordinator;
    }

    async route(taskDescription: string, constraints: any = {}, userPreferences: any = {}): Promise<TaskRoutingDecision> {
        const startTime = Date.now();

        try {
            // Step 1: Classify the task
            const classification = this.taskClassifier.classify(taskDescription);
            
            // Step 2: Get platform recommendation
            const routingDecision = this.platformMatrix.getPlatformForTask(
                classification.type, 
                constraints, 
                userPreferences
            );

            // Step 3: Generate unique task ID
            const taskId = uuidv4();

            const decision: TaskRoutingDecision = {
                taskId,
                platform: routingDecision.platform,
                agent: routingDecision.agent,
                confidence: routingDecision.confidence,
                classification
            };

            // Step 4: Execute task if coordinator available
            if (this.coordinator) {
                const result = await this.coordinator.sendTaskToPlatform(
                    taskId, 
                    routingDecision.platform, 
                    routingDecision.agent
                );

                // Step 5: Track outcome for learning
                const executionTime = Date.now() - startTime;
                this.performanceLearning.trackOutcome(taskId, {
                    taskType: classification.type,
                    platform: routingDecision.platform,
                    agent: routingDecision.agent,
                    result: result,
                    executionTime: executionTime,
                    qualityScore: this.estimateQualityScore(result),
                    costUsd: this.estimateCost(routingDecision.platform, classification.type)
                });

                // Periodic adaptation
                if (Math.random() < 0.1) { // 10% chance
                    this.performanceLearning.adaptRouting();
                }
            }

            console.log(`🎯 Task routed: ${classification.type} → ${routingDecision.platform}/${routingDecision.agent} (${(routingDecision.confidence * 100).toFixed(0)}% confidence)`);
            
            return decision;

        } catch (error) {
            console.error("❌ Error routing task:", error);
            
            // Fallback decision
            return {
                taskId: uuidv4(),
                platform: 'Synthetic.new',
                agent: 'auto',
                confidence: 0.5,
                classification: { type: 'mixed', confidence: 0.5 }
            };
        }
    }

    private estimateQualityScore(result: any): number {
        // Simple heuristic for quality scoring
        if (!result) return 0.3;
        if (result.status === 'completed') return 0.8;
        if (result.status === 'success') return 0.9;
        return 0.5;
    }

    private estimateCost(platform: string, taskType: string): number {
        // Cost estimation based on platform and task type
        if (platform === 'Synthetic.new') {
            return 0.0; // Flat fee model
        } else if (platform === 'OpenRouter') {
            const baseCost = 0.02; // Base cost per task
            const complexityMultiplier = taskType === 'mixed' ? 2.0 : 1.0;
            return baseCost * complexityMultiplier;
        }
        return 0.01; // Default estimate
    }

    getPerformanceMetrics(): PerformanceLearning {
        return this.performanceLearning;
    }

    close(): void {
        this.performanceLearning.close();
    }
}

// Export for testing
export { SimpleTaskClassifier, PlatformSpecializationMatrix, PerformanceLearning };