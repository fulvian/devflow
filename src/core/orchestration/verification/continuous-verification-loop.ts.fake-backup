import * as fs from 'fs';
import * as path from 'path';
import { EventEmitter } from 'events';
import { CodeRealityCheckAgent } from './code-reality-check-agent';
import { IntegrationVerificationAgent } from './integration-verification-agent';
import { SyntheticVerificationOrchestrator, VerificationEvent, VerificationResult } from './synthetic-verification-orchestrator';

/**
 * Continuous Verification Loop - DEVFLOW-LOOP-001
 * Coordina i due agenti di verifica con trigger su task completion
 *
 * Features:
 * - Trigger su chiusura task completion
 * - Auto-disattivazione se nessuna attivit√†
 * - Priorit√† alta: interruzione task in corso se errori critici
 * - Event-driven architecture
 * - Task completion detection
 */

interface Task {
  task: string;
  branch: string;
  services: string[];
  updated: string;
  status?: 'pending' | 'in_progress' | 'completed' | 'failed';
  codeChanges?: {
    codeBlocks: Array<{code: string, language: string}>;
    fileReferences: string[];
    timestamp: string;
  };
}

interface Alert {
  id: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  source: 'code-reality-check' | 'integration-verification' | 'synthetic-orchestrator';
  timestamp: string;
  resolved: boolean;
}

interface VerificationAgent {
  name: string;
  verify(task: Task): Promise<Alert[]>;
  isActive(): boolean;
}

export class ContinuousVerificationLoop extends EventEmitter {
  private readonly STATE_FILE_PATH = '.claude/state/current_task.json';
  private readonly VERIFICATION_TRIGGER_PATH = '.devflow/verification-trigger.json';
  private readonly CHECK_INTERVAL = 10000; // 10 seconds
  private readonly INACTIVITY_THRESHOLD = 86400000; // 24 hours

  private fileWatchInterval: NodeJS.Timeout | null = null;
  private triggerWatchInterval: NodeJS.Timeout | null = null;
  private lastActivityTime: number = Date.now();
  private isRunning: boolean = false;
  private checkInterval: NodeJS.Timeout | null = null;
  private agents: VerificationAgent[];
  private syntheticOrchestrator: SyntheticVerificationOrchestrator;
  private currentTask: Task | null = null;
  private lastTaskHash: string = '';
  private lastTriggerHash: string = '';

  constructor() {
    super();

    // Initialize Synthetic orchestrator
    this.syntheticOrchestrator = new SyntheticVerificationOrchestrator();

    // Initialize real agents
    this.agents = [
      this.createCodeRealityCheckAgentWrapper(),
      this.createIntegrationVerificationAgentWrapper(),
      this.createSyntheticOrchestratorWrapper()
    ];

    console.log('üîÑ Continuous Verification Loop initialized with 3 agents (including Synthetic orchestrator)');
  }

  /**
   * Create wrapper for Code Reality Check Agent
   */
  private createCodeRealityCheckAgentWrapper(): VerificationAgent {
    const agent = new CodeRealityCheckAgent();

    return {
      name: 'code-reality-check',
      async verify(task: Task): Promise<Alert[]> {
        try {
          await agent.startBatchVerification();
          return []; // In real implementation, would return actual alerts
        } catch (error) {
          return [{
            id: `crc-${Date.now()}`,
            severity: 'high',
            message: `Code Reality Check failed: ${(error as Error).message}`,
            source: 'code-reality-check',
            timestamp: new Date().toISOString(),
            resolved: false
          }];
        }
      },
      isActive: () => true
    };
  }

  /**
   * Create wrapper for Integration Verification Agent
   */
  private createIntegrationVerificationAgentWrapper(): VerificationAgent {
    const agent = new IntegrationVerificationAgent();

    return {
      name: 'integration-verification',
      async verify(task: Task): Promise<Alert[]> {
        try {
          const result = await agent.runValidation();

          if (result.status === 'failed' || result.status === 'error') {
            return [{
              id: `iva-${Date.now()}`,
              severity: result.status === 'error' ? 'critical' : 'high',
              message: `Integration verification ${result.status}: ${result.error || 'Build/test failures detected'}`,
              source: 'integration-verification',
              timestamp: new Date().toISOString(),
              resolved: false
            }];
          }

          return [];
        } catch (error) {
          return [{
            id: `iva-${Date.now()}`,
            severity: 'critical',
            message: `Integration Verification failed: ${(error as Error).message}`,
            source: 'integration-verification',
            timestamp: new Date().toISOString(),
            resolved: false
          }];
        }
      },
      isActive: () => true
    };
  }

  /**
   * Start the continuous verification loop
   */
  async start(): Promise<void> {
    if (this.isRunning) {
      console.warn('üîÑ Continuous Verification Loop is already running');
      return;
    }

    console.log('üîÑ Starting Continuous Verification Loop...');
    this.isRunning = true;
    this.lastActivityTime = Date.now();

    try {
      // Setup file monitoring (using polling since chokidar is not installed)
      this.setupFileMonitoring();

      // Setup trigger file monitoring for code changes
      this.setupTriggerFileMonitoring();

      // Start periodic checks
      this.startPeriodicChecks();

      // Load initial task state
      await this.loadCurrentTask();

      console.log('‚úÖ Continuous Verification Loop started successfully');
      this.emit('loop-started');
    } catch (error) {
      console.error('‚ùå Failed to start Continuous Verification Loop:', error);
      this.isRunning = false;
      throw error;
    }
  }

  /**
   * Stop the continuous verification loop
   */
  async stop(): Promise<void> {
    console.log('üîÑ Stopping Continuous Verification Loop...');

    this.isRunning = false;

    if (this.fileWatchInterval) {
      clearInterval(this.fileWatchInterval);
      this.fileWatchInterval = null;
    }

    if (this.triggerWatchInterval) {
      clearInterval(this.triggerWatchInterval);
      this.triggerWatchInterval = null;
    }

    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }

    console.log('‚úÖ Continuous Verification Loop stopped');
    this.emit('loop-stopped');
  }

  /**
   * Setup file monitoring using polling
   */
  private setupFileMonitoring(): void {
    this.fileWatchInterval = setInterval(async () => {
      if (!this.isRunning) return;

      try {
        const currentHash = this.getFileHash();

        if (currentHash !== this.lastTaskHash) {
          console.log('üìù Task state file changed detected');
          this.lastActivityTime = Date.now();
          this.lastTaskHash = currentHash;
          await this.handleTaskChange();
        }
      } catch (error) {
        // File doesn't exist or can't be read - that's ok
      }
    }, 2000); // Check every 2 seconds
  }

  /**
   * Setup trigger file monitoring for code changes detected by hooks
   */
  private setupTriggerFileMonitoring(): void {
    this.triggerWatchInterval = setInterval(async () => {
      if (!this.isRunning) return;

      try {
        const currentTriggerHash = this.getTriggerFileHash();

        if (currentTriggerHash !== this.lastTriggerHash && currentTriggerHash !== '') {
          console.log('üî• Code change trigger detected - starting immediate verification');
          this.lastActivityTime = Date.now();
          this.lastTriggerHash = currentTriggerHash;
          await this.handleCodeChangeTrigger();
        }
      } catch (error) {
        // File doesn't exist or can't be read - that's ok
      }
    }, 1000); // Check every 1 second for faster response
  }

  /**
   * Get hash of current task file for change detection
   */
  private getFileHash(): string {
    try {
      if (fs.existsSync(this.STATE_FILE_PATH)) {
        const content = fs.readFileSync(this.STATE_FILE_PATH, 'utf8');
        // Simple hash - could use crypto.createHash for better hashing
        return content.length + '-' + content.substring(0, 100);
      }
      return '';
    } catch (error) {
      return '';
    }
  }

  /**
   * Get hash of trigger file for code change detection
   */
  private getTriggerFileHash(): string {
    try {
      if (fs.existsSync(this.VERIFICATION_TRIGGER_PATH)) {
        const content = fs.readFileSync(this.VERIFICATION_TRIGGER_PATH, 'utf8');
        return content.length + '-' + content.substring(0, 100);
      }
      return '';
    } catch (error) {
      return '';
    }
  }

  /**
   * Handle code change trigger from hooks
   */
  private async handleCodeChangeTrigger(): Promise<void> {
    try {
      if (!fs.existsSync(this.VERIFICATION_TRIGGER_PATH)) {
        return;
      }

      const triggerData = JSON.parse(fs.readFileSync(this.VERIFICATION_TRIGGER_PATH, 'utf8'));
      console.log(`üéØ Code changes detected: ${triggerData.codeBlocks?.length || 0} blocks, ${triggerData.fileReferences?.length || 0} files`);

      // Load current task for verification context
      await this.loadCurrentTask();

      if (this.currentTask) {
        // Create enhanced task with code change context
        const enhancedTask: Task = {
          ...this.currentTask,
          status: 'in_progress',
          codeChanges: triggerData
        };

        // Trigger immediate verification
        await this.triggerVerification(enhancedTask);
      }

      // Clean up trigger file after processing
      try {
        fs.unlinkSync(this.VERIFICATION_TRIGGER_PATH);
      } catch (error) {
        console.warn('Could not clean up trigger file:', error);
      }
    } catch (error) {
      console.error('‚ùå Error handling code change trigger:', error);
      this.emit('error', error);
    }
  }

  /**
   * Start periodic checks for inactivity
   */
  private startPeriodicChecks(): void {
    this.checkInterval = setInterval(() => {
      if (!this.isRunning) return;
      this.checkInactivity();
    }, this.CHECK_INTERVAL);
  }

  /**
   * Check for system inactivity and auto-deactivate if needed
   */
  private checkInactivity(): void {
    const now = Date.now();
    const inactivityDuration = now - this.lastActivityTime;

    if (inactivityDuration > this.INACTIVITY_THRESHOLD) {
      console.log('üò¥ No activity detected for 5 minutes. Auto-deactivating...');
      this.emit('inactive');
      // Reduce resource usage but don't stop completely
    }
  }

  /**
   * Load current task from state file
   */
  private async loadCurrentTask(): Promise<void> {
    try {
      if (fs.existsSync(this.STATE_FILE_PATH)) {
        const data = fs.readFileSync(this.STATE_FILE_PATH, 'utf8');
        this.currentTask = JSON.parse(data);
        console.log(`üìã Current task loaded: ${this.currentTask?.task}`);
      }
    } catch (error) {
      console.error('‚ùå Failed to load current task:', error);
      this.emit('error', error);
    }
  }

  /**
   * Handle task state changes
   */
  private async handleTaskChange(): Promise<void> {
    try {
      const previousTask = this.currentTask;
      await this.loadCurrentTask();

      // Check if this is a task completion
      if (this.currentTask && this.isTaskTransitionComplete(previousTask, this.currentTask)) {
        console.log(`üéØ Task ${this.currentTask.task} completed. Triggering verification.`);
        await this.triggerVerification(this.currentTask);
      }
    } catch (error) {
      console.error('‚ùå Error handling task change:', error);
      this.emit('error', error);
    }
  }

  /**
   * Check if this represents a task completion transition
   */
  private isTaskTransitionComplete(previous: Task | null, current: Task): boolean {
    // Check if updated timestamp is recent (within last hour)
    const updatedTime = new Date(current.updated).getTime();
    const now = Date.now();
    const oneHour = 60 * 60 * 1000;

    return (now - updatedTime) < oneHour;
  }

  /**
   * Trigger verification process for a completed task with Synthetic enhancement
   */
  private async triggerVerification(task: Task): Promise<void> {
    console.log(`üîç Starting enhanced verification for task: ${task.task}`);

    const allAlerts: Alert[] = [];

    try {
      // Run traditional verification agents
      const traditionaAgentPromises = this.agents
        .filter(agent => agent.isActive() && agent.name !== 'synthetic-orchestrator')
        .map(agent => this.runAgentVerification(agent, task));

      const traditionalResults = await Promise.allSettled(traditionaAgentPromises);

      // Combine traditional results
      traditionalResults.forEach((result, index) => {
        const agentIndex = this.agents.findIndex(a => a.isActive() && a.name !== 'synthetic-orchestrator');
        if (result.status === 'fulfilled') {
          allAlerts.push(...result.value);
        } else {
          console.error(`Agent ${this.agents[agentIndex + index]?.name} failed:`, result.reason);
          allAlerts.push({
            id: `agent-error-${Date.now()}`,
            severity: 'high',
            message: `Agent ${this.agents[agentIndex + index]?.name} failed: ${result.reason}`,
            source: this.agents[agentIndex + index]?.name as any,
            timestamp: new Date().toISOString(),
            resolved: false
          });
        }
      });

      // Run Synthetic orchestrator verification
      try {
        const syntheticResult = await this.runSyntheticVerification(task);

        // Convert Synthetic alerts to our format
        if (syntheticResult.details.alerts) {
          syntheticResult.details.alerts.forEach(alert => {
            allAlerts.push({
              id: `synthetic-${Date.now()}-${Math.random()}`,
              severity: alert.priority as any,
              message: alert.message,
              source: 'synthetic-orchestrator',
              timestamp: new Date().toISOString(),
              resolved: false
            });
          });
        }

        console.log(`ü§ñ Synthetic verification completed with score: ${syntheticResult.score}`);
      } catch (error) {
        console.error('‚ùå Synthetic verification failed:', error);
        allAlerts.push({
          id: `synthetic-error-${Date.now()}`,
          severity: 'high',
          message: `Synthetic verification failed: ${(error as Error).message}`,
          source: 'synthetic-orchestrator',
          timestamp: new Date().toISOString(),
          resolved: false
        });
      }

      // Handle critical alerts
      const criticalAlerts = allAlerts.filter(alert => alert.severity === 'critical');
      if (criticalAlerts.length > 0) {
        console.warn(`üö® Found ${criticalAlerts.length} critical alerts. Interrupting current tasks.`);
        this.emit('critical-alerts', criticalAlerts);
      }

      // Emit verification complete event
      this.emit('verification-complete', { task, alerts: allAlerts });

      console.log(`‚úÖ Enhanced verification completed for task: ${task.task} (${allAlerts.length} alerts)`);
    } catch (error) {
      console.error(`‚ùå Verification failed for task ${task.task}:`, error);
      this.emit('verification-error', { task, error });
    }
  }

  /**
   * Run verification for a specific agent
   */
  private async runAgentVerification(agent: VerificationAgent, task: Task): Promise<Alert[]> {
    try {
      console.log(`ü§ñ Running verification with ${agent.name} for task: ${task.task}`);
      const alerts = await agent.verify(task);
      console.log(`üìä ${agent.name} found ${alerts.length} alerts`);
      return alerts;
    } catch (error) {
      console.error(`‚ùå Verification failed for agent ${agent.name}:`, error);
      this.emit('agent-error', { agent: agent.name, error });
      return [];
    }
  }

  /**
   * Get current status of the verification loop
   */
  getStatus(): {
    running: boolean;
    lastActivity: number;
    currentTaskName: string | null;
    activeAgents: number;
  } {
    return {
      running: this.isRunning,
      lastActivity: this.lastActivityTime,
      currentTaskName: this.currentTask?.task || null,
      activeAgents: this.agents.filter(agent => agent.isActive()).length
    };
  }

  /**
   * Create wrapper for Synthetic Verification Orchestrator
   */
  private createSyntheticOrchestratorWrapper(): VerificationAgent {
    return {
      name: 'synthetic-orchestrator',
      async verify(task: Task): Promise<Alert[]> {
        // This is handled separately in triggerVerification
        return [];
      },
      isActive: () => true
    };
  }

  /**
   * Run Synthetic verification for a task
   */
  private async runSyntheticVerification(task: Task): Promise<VerificationResult> {
    // Create verification event from task
    const verificationEvent: VerificationEvent = {
      id: `task-${task.task}-${Date.now()}`,
      code: await this.getTaskCode(task),
      metadata: {
        requirements: `Task: ${task.task}`,
        services: task.services,
        branch: task.branch,
        updated: task.updated
      }
    };

    return await this.syntheticOrchestrator.processVerificationEvent(verificationEvent);
  }

  /**
   * Get code content for task verification
   */
  private async getTaskCode(task: Task): Promise<string> {
    try {
      const codeContent: string[] = [];

      // If we have code changes from hooks, use them first
      if (task.codeChanges) {
        console.log('üìù Using code changes from hook trigger');

        // Add code blocks from hooks
        task.codeChanges.codeBlocks.forEach((block, index) => {
          codeContent.push(`// Code Block ${index + 1} (${block.language})\n${block.code}\n`);
        });

        // Add file references content
        for (const filePath of task.codeChanges.fileReferences.slice(0, 3)) {
          try {
            const fullPath = path.join(process.cwd(), filePath);
            if (fs.existsSync(fullPath)) {
              const content = fs.readFileSync(fullPath, 'utf-8');
              codeContent.push(`// File: ${filePath}\n${content.substring(0, 2000)}\n`);
            }
          } catch (error) {
            console.warn(`Could not read file ${filePath}:`, error);
          }
        }
      } else {
        // Fallback to git diff approach
        const changedFiles = this.getChangedFiles();

        for (const filePath of changedFiles.slice(0, 3)) { // Limit to 3 files
          try {
            const fullPath = path.join(process.cwd(), filePath);
            if (fs.existsSync(fullPath)) {
              const content = fs.readFileSync(fullPath, 'utf-8');
              codeContent.push(`// File: ${filePath}\n${content.substring(0, 2000)}\n`);
            }
          } catch (error) {
            console.warn(`Could not read file ${filePath}:`, error);
          }
        }
      }

      return codeContent.join('\n\n') || `// Task: ${task.task}\n// No specific code files detected`;
    } catch (error) {
      return `// Task: ${task.task}\n// Error reading code: ${(error as Error).message}`;
    }
  }

  /**
   * Get changed files from git
   */
  private getChangedFiles(): string[] {
    try {
      const { execSync } = require('child_process');
      const output = execSync('git diff --name-only HEAD~1 HEAD', {
        cwd: process.cwd(),
        encoding: 'utf-8'
      });
      return output.trim().split('\n').filter(file => file.length > 0);
    } catch (error) {
      return [];
    }
  }

  /**
   * Force trigger verification for current task (for testing)
   */
  async forceVerification(): Promise<void> {
    if (this.currentTask) {
      console.log('üîß Force triggering enhanced verification...');
      await this.triggerVerification(this.currentTask);
    } else {
      console.warn('‚ö†Ô∏è  No current task to verify');
    }
  }

  /**
   * Get Synthetic orchestrator status
   */
  getSyntheticStatus(): any {
    return this.syntheticOrchestrator.getStatus();
  }
}

export type { Task, Alert, VerificationAgent };
export default ContinuousVerificationLoop;